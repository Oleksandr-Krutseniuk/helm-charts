{{- if and (not .Values.image.bitnami) (eq .Values.architecture "replication") .Values.sentinel.enabled }}

apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ printf "%s-lib-sentinel-scripts" (include "common.names.fullname" .) }}
  namespace: {{ .Release.Namespace | quote }}
  labels: {{- include "common.labels.standard" ( dict "customLabels" .Values.commonLabels "context" $ ) | nindent 4 }}
  {{- if .Values.commonAnnotations }}
  annotations: {{- include "common.tplvalues.render" ( dict "value" .Values.commonAnnotations "context" $ ) | nindent 4 }}
  {{- end }}
data:
  entrypoint.sh: |
    #!/bin/bash
    # Copyright Broadcom, Inc. All Rights Reserved.
    # SPDX-License-Identifier: APACHE-2.0

    # shellcheck disable=SC1091

    set -o errexit
    set -o nounset
    set -o pipefail
    # set -o xtrace # Uncomment this line for debugging purposes

    # Load Redis Sentinel environment variables
    . /etc/redis_scripts/redis-sentinel-env.sh

    # Load libraries
    . /etc/redis_scripts/libredissentinel.sh
    . /etc/redis_scripts/libbitnami.sh
    . /etc/redis_scripts/liblog.sh

    print_welcome_page

    if [[ "$*" == *"/etc/redis_scripts/redis-sentinel/run.sh"* ]]; then
        info "** Starting Redis sentinel setup **"
        /etc/redis_scripts/redis-sentinel/setup.sh
        info "** Redis sentinel setup finished! **"
    fi

    echo ""
    exec "$@"
  postunpack.sh: |
    #!/bin/bash
    # Copyright Broadcom, Inc. All Rights Reserved.
    # SPDX-License-Identifier: APACHE-2.0

    # shellcheck disable=SC1091

    set -o errexit
    set -o nounset
    set -o pipefail
    # set -o xtrace # Uncomment this line for debugging purposes

    # Load Redis Sentinel environment variables
    . /etc/redis_scripts/redis-sentinel-env.sh

    # Load libraries
    . /etc/redis_scripts/libredissentinel.sh
    . /etc/redis_scripts/libfs.sh
    . /etc/redis_scripts/liblog.sh

    # Ensure non-root user has write permissions on a set of directories
    for dir in "$REDIS_SENTINEL_BASE_DIR" "$REDIS_SENTINEL_CONF_DIR" "$REDIS_SENTINEL_LOG_DIR" "$REDIS_SENTINEL_TMP_DIR" "$REDIS_SENTINEL_VOLUME_DIR" "${REDIS_SENTINEL_VOLUME_DIR}/conf" "$REDIS_SENTINEL_DEFAULT_CONF_DIR"; do
        ensure_dir_exists "$dir"
        chmod -R g+rwX "$dir"
    done

    # Redis Sentinel defaults
    redis_conf_set "port" "$REDIS_SENTINEL_DEFAULT_PORT_NUMBER"
    redis_conf_set "bind" "0.0.0.0"
    redis_conf_set "pidfile" "$REDIS_SENTINEL_PID_FILE"
    # Send logs to stdout
    redis_conf_set "daemonize" "no"
    redis_conf_set "logfile" ""

    # Copy all initially generated configuration files to the default directory
    # (this is to avoid breaking when entrypoint is being overridden)
    cp -r "${REDIS_SENTINEL_CONF_DIR}/"* "$REDIS_SENTINEL_DEFAULT_CONF_DIR"
  run.sh: |
    #!/bin/bash
    # Copyright Broadcom, Inc. All Rights Reserved.
    # SPDX-License-Identifier: APACHE-2.0

    # shellcheck disable=SC1091

    set -o errexit
    set -o nounset
    set -o pipefail
    # set -o xtrace # Uncomment this line for debugging purposes

    # Load Redis Sentinel environment variables
    . /etc/redis_scripts/redis-sentinel-env.sh

    # Load libraries
    . /etc/redis_scripts/libredissentinel.sh
    . /etc/redis_scripts/liblog.sh
    . /etc/redis_scripts/libos.sh

    args=("$REDIS_SENTINEL_CONF_FILE" "--daemonize" "no" "$@")

    info "** Starting Redis Sentinel **"
    if am_i_root; then
        exec_as_user "$REDIS_SENTINEL_DAEMON_USER" redis-sentinel "${args[@]}"
    else
        exec redis-sentinel "${args[@]}"
    fi
  setup.sh: |
    #!/bin/bash
    # Copyright Broadcom, Inc. All Rights Reserved.
    # SPDX-License-Identifier: APACHE-2.0

    # shellcheck disable=SC1091

    set -o errexit
    set -o nounset
    set -o pipefail
    # set -o xtrace # Uncomment this line for debugging purposes

    # Load Redis Sentinel environment variables
    . /etc/redis_scripts/redis-sentinel-env.sh

    # Load libraries
    . /etc/redis_scripts/libredissentinel.sh
    . /etc/redis_scripts/libos.sh

    # Create daemon user if needed
    am_i_root && ensure_user_exists "$REDIS_SENTINEL_DAEMON_USER" --group "$REDIS_SENTINEL_DAEMON_GROUP"

    # Ensure redis environment variables are valid
    redis_validate

    # Initialize redis sentinel
    redis_initialize
  libbitnami.sh: |
    #!/bin/bash
    # Copyright Broadcom, Inc. All Rights Reserved.
    # SPDX-License-Identifier: APACHE-2.0
    #
    # Bitnami custom library

    # shellcheck disable=SC1091

    # Load Generic Libraries
    . /etc/redis_scripts/liblog.sh

    # Constants
    BOLD='\033[1m'

    # Functions

    ########################
    # Print the welcome page
    # Globals:
    #   DISABLE_WELCOME_MESSAGE
    #   BITNAMI_APP_NAME
    # Arguments:
    #   None
    # Returns:
    #   None
    #########################
    print_welcome_page() {
        if [[ -z "${DISABLE_WELCOME_MESSAGE:-}" ]]; then
            if [[ -n "$BITNAMI_APP_NAME" ]]; then
                print_image_welcome_page
            fi
        fi
    }

    ########################
    # Print the welcome page for a Bitnami Docker image
    # Globals:
    #   BITNAMI_APP_NAME
    # Arguments:
    #   None
    # Returns:
    #   None
    #########################
    print_image_welcome_page() {
        local github_url="https://github.com/bitnami/containers"

        info ""
        info "${BOLD}Welcome to the Bitnami ${BITNAMI_APP_NAME} container${RESET}"
        info "Subscribe to project updates by watching ${BOLD}${github_url}${RESET}"
        info "Submit issues and feature requests at ${BOLD}${github_url}/issues${RESET}"
        info "Upgrade to Tanzu Application Catalog for production environments to access custom-configured and pre-packaged software components. Gain enhanced features, including Software Bill of Materials (SBOM), CVE scan result reports, and VEX documents. To learn more, visit ${BOLD}https://bitnami.com/enterprise${RESET}"
        info ""
    }
  libfile.sh: |
    #!/bin/bash
    # Copyright Broadcom, Inc. All Rights Reserved.
    # SPDX-License-Identifier: APACHE-2.0
    #
    # Library for managing files

    # shellcheck disable=SC1091

    # Load Generic Libraries
    . /etc/redis_scripts/libos.sh

    # Functions

    ########################
    # Replace a regex-matching string in a file
    # Arguments:
    #   $1 - filename
    #   $2 - match regex
    #   $3 - substitute regex
    #   $4 - use POSIX regex. Default: true
    # Returns:
    #   None
    #########################
    replace_in_file() {
        local filename="${1:?filename is required}"
        local match_regex="${2:?match regex is required}"
        local substitute_regex="${3:?substitute regex is required}"
        local posix_regex=${4:-true}

        local result

        # We should avoid using 'sed in-place' substitutions
        # 1) They are not compatible with files mounted from ConfigMap(s)
        # 2) We found incompatibility issues with Debian10 and "in-place" substitutions
        local -r del=$'\001' # Use a non-printable character as a 'sed' delimiter to avoid issues
        if [[ $posix_regex = true ]]; then
            result="$(sed -E "s${del}${match_regex}${del}${substitute_regex}${del}g" "$filename")"
        else
            result="$(sed "s${del}${match_regex}${del}${substitute_regex}${del}g" "$filename")"
        fi
        echo "$result" > "$filename"
    }

    ########################
    # Replace a regex-matching multiline string in a file
    # Arguments:
    #   $1 - filename
    #   $2 - match regex
    #   $3 - substitute regex
    # Returns:
    #   None
    #########################
    replace_in_file_multiline() {
        local filename="${1:?filename is required}"
        local match_regex="${2:?match regex is required}"
        local substitute_regex="${3:?substitute regex is required}"

        local result
        local -r del=$'\001' # Use a non-printable character as a 'sed' delimiter to avoid issues
        result="$(perl -pe "BEGIN{undef $/;} s${del}${match_regex}${del}${substitute_regex}${del}sg" "$filename")"
        echo "$result" > "$filename"
    }

    ########################
    # Remove a line in a file based on a regex
    # Arguments:
    #   $1 - filename
    #   $2 - match regex
    #   $3 - use POSIX regex. Default: true
    # Returns:
    #   None
    #########################
    remove_in_file() {
        local filename="${1:?filename is required}"
        local match_regex="${2:?match regex is required}"
        local posix_regex=${3:-true}
        local result

        # We should avoid using 'sed in-place' substitutions
        # 1) They are not compatible with files mounted from ConfigMap(s)
        # 2) We found incompatibility issues with Debian10 and "in-place" substitutions
        if [[ $posix_regex = true ]]; then
            result="$(sed -E "/$match_regex/d" "$filename")"
        else
            result="$(sed "/$match_regex/d" "$filename")"
        fi
        echo "$result" > "$filename"
    }

    ########################
    # Appends text after the last line matching a pattern
    # Arguments:
    #   $1 - file
    #   $2 - match regex
    #   $3 - contents to add
    # Returns:
    #   None
    #########################
    append_file_after_last_match() {
        local file="${1:?missing file}"
        local match_regex="${2:?missing pattern}"
        local value="${3:?missing value}"

        # We read the file in reverse, replace the first match (0,/pattern/s) and then reverse the results again
        result="$(tac "$file" | sed -E "0,/($match_regex)/s||${value}\n\1|" | tac)"
        echo "$result" > "$file"
    }

    ########################
    # Wait until certain entry is present in a log file
    # Arguments:
    #   $1 - entry to look for
    #   $2 - log file
    #   $3 - max retries. Default: 12
    #   $4 - sleep between retries (in seconds). Default: 5
    # Returns:
    #   Boolean
    #########################
    wait_for_log_entry() {
        local -r entry="${1:-missing entry}"
        local -r log_file="${2:-missing log file}"
        local -r retries="${3:-12}"
        local -r interval_time="${4:-5}"
        local attempt=0

        check_log_file_for_entry() {
            if ! grep -qE "$entry" "$log_file"; then
                debug "Entry \"${entry}\" still not present in ${log_file} (attempt $((++attempt))/${retries})"
                return 1
            fi
        }
        debug "Checking that ${log_file} log file contains entry \"${entry}\""
        if retry_while check_log_file_for_entry "$retries" "$interval_time"; then
            debug "Found entry \"${entry}\" in ${log_file}"
            true
        else
            error "Could not find entry \"${entry}\" in ${log_file} after ${retries} retries"
            debug_execute cat "$log_file"
            return 1
        fi
    }
  libfs.sh: |
    #!/bin/bash
    # Copyright Broadcom, Inc. All Rights Reserved.
    # SPDX-License-Identifier: APACHE-2.0
    #
    # Library for file system actions

    # shellcheck disable=SC1091

    # Load Generic Libraries
    . /etc/redis_scripts/liblog.sh

    # Functions

    ########################
    # Ensure a file/directory is owned (user and group) but the given user
    # Arguments:
    #   $1 - filepath
    #   $2 - owner
    # Returns:
    #   None
    #########################
    owned_by() {
        local path="${1:?path is missing}"
        local owner="${2:?owner is missing}"
        local group="${3:-}"

        if [[ -n $group ]]; then
            chown "$owner":"$group" "$path"
        else
            chown "$owner":"$owner" "$path"
        fi
    }

    ########################
    # Ensure a directory exists and, optionally, is owned by the given user
    # Arguments:
    #   $1 - directory
    #   $2 - owner
    # Returns:
    #   None
    #########################
    ensure_dir_exists() {
        local dir="${1:?directory is missing}"
        local owner_user="${2:-}"
        local owner_group="${3:-}"

        [ -d "${dir}" ] || mkdir -p "${dir}"
        if [[ -n $owner_user ]]; then
            owned_by "$dir" "$owner_user" "$owner_group"
        fi
    }

    ########################
    # Checks whether a directory is empty or not
    # arguments:
    #   $1 - directory
    # returns:
    #   boolean
    #########################
    is_dir_empty() {
        local -r path="${1:?missing directory}"
        # Calculate real path in order to avoid issues with symlinks
        local -r dir="$(realpath "$path")"
        if [[ ! -e "$dir" ]] || [[ -z "$(ls -A "$dir")" ]]; then
            true
        else
            false
        fi
    }

    ########################
    # Checks whether a mounted directory is empty or not
    # arguments:
    #   $1 - directory
    # returns:
    #   boolean
    #########################
    is_mounted_dir_empty() {
        local dir="${1:?missing directory}"

        if is_dir_empty "$dir" || find "$dir" -mindepth 1 -maxdepth 1 -not -name ".snapshot" -not -name "lost+found" -exec false {} +; then
            true
        else
            false
        fi
    }

    ########################
    # Checks whether a file can be written to or not
    # arguments:
    #   $1 - file
    # returns:
    #   boolean
    #########################
    is_file_writable() {
        local file="${1:?missing file}"
        local dir
        dir="$(dirname "$file")"

        if [[ (-f "$file" && -w "$file") || (! -f "$file" && -d "$dir" && -w "$dir") ]]; then
            true
        else
            false
        fi
    }

    ########################
    # Relativize a path
    # arguments:
    #   $1 - path
    #   $2 - base
    # returns:
    #   None
    #########################
    relativize() {
        local -r path="${1:?missing path}"
        local -r base="${2:?missing base}"
        pushd "$base" >/dev/null || exit
        realpath -q --no-symlinks --relative-base="$base" "$path" | sed -e 's|^/$|.|' -e 's|^/||'
        popd >/dev/null || exit
    }

    ########################
    # Configure permisions and ownership recursively
    # Globals:
    #   None
    # Arguments:
    #   $1 - paths (as a string).
    # Flags:
    #   -f|--file-mode - mode for directories.
    #   -d|--dir-mode - mode for files.
    #   -u|--user - user
    #   -g|--group - group
    # Returns:
    #   None
    #########################
    configure_permissions_ownership() {
        local -r paths="${1:?paths is missing}"
        local dir_mode=""
        local file_mode=""
        local user=""
        local group=""

        # Validate arguments
        shift 1
        while [ "$#" -gt 0 ]; do
            case "$1" in
            -f | --file-mode)
                shift
                file_mode="${1:?missing mode for files}"
                ;;
            -d | --dir-mode)
                shift
                dir_mode="${1:?missing mode for directories}"
                ;;
            -u | --user)
                shift
                user="${1:?missing user}"
                ;;
            -g | --group)
                shift
                group="${1:?missing group}"
                ;;
            *)
                echo "Invalid command line flag $1" >&2
                return 1
                ;;
            esac
            shift
        done

        read -r -a filepaths <<<"$paths"
        for p in "${filepaths[@]}"; do
            if [[ -e "$p" ]]; then
                find -L "$p" -printf ""
                if [[ -n $dir_mode ]]; then
                    find -L "$p" -type d ! -perm "$dir_mode" -print0 | xargs -r -0 chmod "$dir_mode"
                fi
                if [[ -n $file_mode ]]; then
                    find -L "$p" -type f ! -perm "$file_mode" -print0 | xargs -r -0 chmod "$file_mode"
                fi
                if [[ -n $user ]] && [[ -n $group ]]; then
                    find -L "$p" -print0 | xargs -r -0 chown "${user}:${group}"
                elif [[ -n $user ]] && [[ -z $group ]]; then
                    find -L "$p" -print0 | xargs -r -0 chown "${user}"
                elif [[ -z $user ]] && [[ -n $group ]]; then
                    find -L "$p" -print0 | xargs -r -0 chgrp "${group}"
                fi
            else
                stderr_print "$p does not exist"
            fi
        done
    }
  libhook.sh: |
    #!/bin/bash
    # Copyright Broadcom, Inc. All Rights Reserved.
    # SPDX-License-Identifier: APACHE-2.0
    #
    # Library to use for scripts expected to be used as Kubernetes lifecycle hooks

    # shellcheck disable=SC1091

    # Load generic libraries
    . /etc/redis_scripts/liblog.sh
    . /etc/redis_scripts/libos.sh

    # Override functions that log to stdout/stderr of the current process, so they print to process 1
    for function_to_override in stderr_print debug_execute; do
        # Output is sent to output of process 1 and thus end up in the container log
        # The hook output in general isn't saved
        eval "$(declare -f "$function_to_override") >/proc/1/fd/1 2>/proc/1/fd/2"
    done
  liblog.sh: |
    #!/bin/bash
    # Copyright Broadcom, Inc. All Rights Reserved.
    # SPDX-License-Identifier: APACHE-2.0
    #
    # Library for logging functions

    # Constants
    RESET='\033[0m'
    RED='\033[38;5;1m'
    GREEN='\033[38;5;2m'
    YELLOW='\033[38;5;3m'
    MAGENTA='\033[38;5;5m'
    CYAN='\033[38;5;6m'

    # Functions

    ########################
    # Print to STDERR
    # Arguments:
    #   Message to print
    # Returns:
    #   None
    #########################
    stderr_print() {
        # 'is_boolean_yes' is defined in libvalidations.sh, but depends on this file so we cannot source it
        local bool="${BITNAMI_QUIET:-false}"
        # comparison is performed without regard to the case of alphabetic characters
        shopt -s nocasematch
        if ! [[ "$bool" = 1 || "$bool" =~ ^(yes|true)$ ]]; then
            printf "%b\\n" "${*}" >&2
        fi
    }

    ########################
    # Log message
    # Arguments:
    #   Message to log
    # Returns:
    #   None
    #########################
    log() {
        stderr_print "${CYAN}${MODULE:-} ${MAGENTA}$(date "+%T.%2N ")${RESET}${*}"
    }
    ########################
    # Log an 'info' message
    # Arguments:
    #   Message to log
    # Returns:
    #   None
    #########################
    info() {
        log "${GREEN}INFO ${RESET} ==> ${*}"
    }
    ########################
    # Log message
    # Arguments:
    #   Message to log
    # Returns:
    #   None
    #########################
    warn() {
        log "${YELLOW}WARN ${RESET} ==> ${*}"
    }
    ########################
    # Log an 'error' message
    # Arguments:
    #   Message to log
    # Returns:
    #   None
    #########################
    error() {
        log "${RED}ERROR${RESET} ==> ${*}"
    }
    ########################
    # Log a 'debug' message
    # Globals:
    #   BITNAMI_DEBUG
    # Arguments:
    #   None
    # Returns:
    #   None
    #########################
    debug() {
        # 'is_boolean_yes' is defined in libvalidations.sh, but depends on this file so we cannot source it
        local bool="${BITNAMI_DEBUG:-false}"
        # comparison is performed without regard to the case of alphabetic characters
        shopt -s nocasematch
        if [[ "$bool" = 1 || "$bool" =~ ^(yes|true)$ ]]; then
            log "${MAGENTA}DEBUG${RESET} ==> ${*}"
        fi
    }

    ########################
    # Indent a string
    # Arguments:
    #   $1 - string
    #   $2 - number of indentation characters (default: 4)
    #   $3 - indentation character (default: " ")
    # Returns:
    #   None
    #########################
    indent() {
        local string="${1:-}"
        local num="${2:?missing num}"
        local char="${3:-" "}"
        # Build the indentation unit string
        local indent_unit=""
        for ((i = 0; i < num; i++)); do
            indent_unit="${indent_unit}${char}"
        done
        # shellcheck disable=SC2001
        # Complex regex, see https://github.com/koalaman/shellcheck/wiki/SC2001#exceptions
        echo "$string" | sed "s/^/${indent_unit}/"
    }
  libnet.sh: |
    #!/bin/bash
    # Copyright Broadcom, Inc. All Rights Reserved.
    # SPDX-License-Identifier: APACHE-2.0
    #
    # Library for network functions

    # shellcheck disable=SC1091

    # Load Generic Libraries
    . /etc/redis_scripts/liblog.sh
    . /etc/redis_scripts/libvalidations.sh

    # Functions

    ########################
    # Resolve IP address for a host/domain (i.e. DNS lookup)
    # Arguments:
    #   $1 - Hostname to resolve
    #   $2 - IP address version (v4, v6), leave empty for resolving to any version
    # Returns:
    #   IP
    #########################
    dns_lookup() {
        local host="${1:?host is missing}"
        local ip_version="${2:-}"
        getent "ahosts${ip_version}" "$host" | awk '/STREAM/ {print $1 }' | head -n 1
    }

    #########################
    # Wait for a hostname and return the IP
    # Arguments:
    #   $1 - hostname
    #   $2 - number of retries
    #   $3 - seconds to wait between retries
    # Returns:
    #   - IP address that corresponds to the hostname
    #########################
    wait_for_dns_lookup() {
        local hostname="${1:?hostname is missing}"
        local retries="${2:-5}"
        local seconds="${3:-1}"
        check_host() {
            if [[ $(dns_lookup "$hostname") == "" ]]; then
                false
            else
                true
            fi
        }
        # Wait for the host to be ready
        retry_while "check_host ${hostname}" "$retries" "$seconds"
        dns_lookup "$hostname"
    }

    ########################
    # Get machine's IP
    # Arguments:
    #   None
    # Returns:
    #   Machine IP
    #########################
    get_machine_ip() {
        local -a ip_addresses
        local hostname
        hostname="$(hostname)"
        read -r -a ip_addresses <<< "$(dns_lookup "$hostname" | xargs echo)"
        if [[ "${#ip_addresses[@]}" -gt 1 ]]; then
            warn "Found more than one IP address associated to hostname ${hostname}: ${ip_addresses[*]}, will use ${ip_addresses[0]}"
        elif [[ "${#ip_addresses[@]}" -lt 1 ]]; then
            error "Could not find any IP address associated to hostname ${hostname}"
            exit 1
        fi
        # Check if the first IP address is IPv6 to add brackets
        if validate_ipv6 "${ip_addresses[0]}" ; then
            echo "[${ip_addresses[0]}]"
        else
            echo "${ip_addresses[0]}"
        fi
    }

    ########################
    # Check if the provided argument is a resolved hostname
    # Arguments:
    #   $1 - Value to check
    # Returns:
    #   Boolean
    #########################
    is_hostname_resolved() {
        local -r host="${1:?missing value}"
        if [[ -n "$(dns_lookup "$host")" ]]; then
            true
        else
            false
        fi
    }

    ########################
    # Parse URL
    # Globals:
    #   None
    # Arguments:
    #   $1 - uri - String
    #   $2 - component to obtain. Valid options (scheme, authority, userinfo, host, port, path, query or fragment) - String
    # Returns:
    #   String
    parse_uri() {
        local uri="${1:?uri is missing}"
        local component="${2:?component is missing}"

        # Solution based on https://tools.ietf.org/html/rfc3986#appendix-B with
        # additional sub-expressions to split authority into userinfo, host and port
        # Credits to Patryk Obara (see https://stackoverflow.com/a/45977232/6694969)
        local -r URI_REGEX='^(([^:/?#]+):)?(//((([^@/?#]+)@)?([^:/?#]+)(:([0-9]+))?))?(/([^?#]*))?(\?([^#]*))?(#(.*))?'
        #                    ||            |  |||            |         | |            | |         |  |        | |
        #                    |2 scheme     |  ||6 userinfo   7 host    | 9 port       | 11 rpath  |  13 query | 15 fragment
        #                    1 scheme:     |  |5 userinfo@             8 :...         10 path     12 ?...     14 #...
        #                                  |  4 authority
        #                                  3 //...
        local index=0
        case "$component" in
            scheme)
                index=2
                ;;
            authority)
                index=4
                ;;
            userinfo)
                index=6
                ;;
            host)
                index=7
                ;;
            port)
                index=9
                ;;
            path)
                index=10
                ;;
            query)
                index=13
                ;;
            fragment)
                index=14
                ;;
            *)
                stderr_print "unrecognized component $component"
                return 1
                ;;
        esac
        [[ "$uri" =~ $URI_REGEX ]] && echo "${BASH_REMATCH[${index}]}"
    }

    ########################
    # Wait for a HTTP connection to succeed
    # Globals:
    #   *
    # Arguments:
    #   $1 - URL to wait for
    #   $2 - Maximum amount of retries (optional)
    #   $3 - Time between retries (optional)
    # Returns:
    #   true if the HTTP connection succeeded, false otherwise
    #########################
    wait_for_http_connection() {
        local url="${1:?missing url}"
        local retries="${2:-}"
        local sleep_time="${3:-}"
        if ! retry_while "debug_execute curl --silent ${url}" "$retries" "$sleep_time"; then
            error "Could not connect to ${url}"
            return 1
        fi
    }
  libos.sh: |
    #!/bin/bash
    # Copyright Broadcom, Inc. All Rights Reserved.
    # SPDX-License-Identifier: APACHE-2.0
    #
    # Library for operating system actions

    # shellcheck disable=SC1091

    # Load Generic Libraries
    . /etc/redis_scripts/liblog.sh
    . /etc/redis_scripts/libfs.sh
    . /etc/redis_scripts/libvalidations.sh

    # Functions

    ########################
    # Check if an user exists in the system
    # Arguments:
    #   $1 - user
    # Returns:
    #   Boolean
    #########################
    user_exists() {
        local user="${1:?user is missing}"
        id "$user" >/dev/null 2>&1
    }

    ########################
    # Check if a group exists in the system
    # Arguments:
    #   $1 - group
    # Returns:
    #   Boolean
    #########################
    group_exists() {
        local group="${1:?group is missing}"
        getent group "$group" >/dev/null 2>&1
    }

    ########################
    # Create a group in the system if it does not exist already
    # Arguments:
    #   $1 - group
    # Flags:
    #   -i|--gid - the ID for the new group
    #   -s|--system - Whether to create new user as system user (uid <= 999)
    # Returns:
    #   None
    #########################
    ensure_group_exists() {
        local group="${1:?group is missing}"
        local gid=""
        local is_system_user=false

        # Validate arguments
        shift 1
        while [ "$#" -gt 0 ]; do
            case "$1" in
            -i | --gid)
                shift
                gid="${1:?missing gid}"
                ;;
            -s | --system)
                is_system_user=true
                ;;
            *)
                echo "Invalid command line flag $1" >&2
                return 1
                ;;
            esac
            shift
        done

        if ! group_exists "$group"; then
            local -a args=("$group")
            if [[ -n "$gid" ]]; then
                if group_exists "$gid"; then
                    error "The GID $gid is already in use." >&2
                    return 1
                fi
                args+=("--gid" "$gid")
            fi
            $is_system_user && args+=("--system")
            groupadd "${args[@]}" >/dev/null 2>&1
        fi
    }

    ########################
    # Create an user in the system if it does not exist already
    # Arguments:
    #   $1 - user
    # Flags:
    #   -i|--uid - the ID for the new user
    #   -g|--group - the group the new user should belong to
    #   -a|--append-groups - comma-separated list of supplemental groups to append to the new user
    #   -h|--home - the home directory for the new user
    #   -s|--system - whether to create new user as system user (uid <= 999)
    # Returns:
    #   None
    #########################
    ensure_user_exists() {
        local user="${1:?user is missing}"
        local uid=""
        local group=""
        local append_groups=""
        local home=""
        local is_system_user=false

        # Validate arguments
        shift 1
        while [ "$#" -gt 0 ]; do
            case "$1" in
            -i | --uid)
                shift
                uid="${1:?missing uid}"
                ;;
            -g | --group)
                shift
                group="${1:?missing group}"
                ;;
            -a | --append-groups)
                shift
                append_groups="${1:?missing append_groups}"
                ;;
            -h | --home)
                shift
                home="${1:?missing home directory}"
                ;;
            -s | --system)
                is_system_user=true
                ;;
            *)
                echo "Invalid command line flag $1" >&2
                return 1
                ;;
            esac
            shift
        done

        if ! user_exists "$user"; then
            local -a user_args=("-N" "$user")
            if [[ -n "$uid" ]]; then
                if user_exists "$uid"; then
                    error "The UID $uid is already in use."
                    return 1
                fi
                user_args+=("--uid" "$uid")
            else
                $is_system_user && user_args+=("--system")
            fi
            useradd "${user_args[@]}" >/dev/null 2>&1
        fi

        if [[ -n "$group" ]]; then
            local -a group_args=("$group")
            $is_system_user && group_args+=("--system")
            ensure_group_exists "${group_args[@]}"
            usermod -g "$group" "$user" >/dev/null 2>&1
        fi

        if [[ -n "$append_groups" ]]; then
            local -a groups
            read -ra groups <<<"$(tr ',;' ' ' <<<"$append_groups")"
            for group in "${groups[@]}"; do
                ensure_group_exists "$group"
                usermod -aG "$group" "$user" >/dev/null 2>&1
            done
        fi

        if [[ -n "$home" ]]; then
            mkdir -p "$home"
            usermod -d "$home" "$user" >/dev/null 2>&1
            configure_permissions_ownership "$home" -d "775" -f "664" -u "$user" -g "$group"
        fi
    }

    ########################
    # Check if the script is currently running as root
    # Arguments:
    #   $1 - user
    #   $2 - group
    # Returns:
    #   Boolean
    #########################
    am_i_root() {
        if [[ "$(id -u)" = "0" ]]; then
            true
        else
            false
        fi
    }

    ########################
    # Print OS metadata
    # Arguments:
    #   $1 - Flag name
    # Flags:
    #   --id - Distro ID
    #   --version - Distro version
    #   --branch - Distro branch
    #   --codename - Distro codename
    #   --name - Distro name
    #   --pretty-name - Distro pretty name
    # Returns:
    #   String
    #########################
    get_os_metadata() {
        local -r flag_name="${1:?missing flag}"
        # Helper function
        get_os_release_metadata() {
            local -r env_name="${1:?missing environment variable name}"
            (
                . /etc/os-release
                echo "${!env_name}"
            )
        }
        case "$flag_name" in
        --id)
            get_os_release_metadata ID
            ;;
        --version)
            get_os_release_metadata VERSION_ID
            ;;
        --branch)
            get_os_release_metadata VERSION_ID | sed 's/\..*//'
            ;;
        --codename)
            get_os_release_metadata VERSION_CODENAME
            ;;
        --name)
            get_os_release_metadata NAME
            ;;
        --pretty-name)
            get_os_release_metadata PRETTY_NAME
            ;;
        *)
            error "Unknown flag ${flag_name}"
            return 1
            ;;
        esac
    }

    ########################
    # Get total memory available
    # Arguments:
    #   None
    # Returns:
    #   Memory in bytes
    #########################
    get_total_memory() {
        echo $(($(grep MemTotal /proc/meminfo | awk '{print $2}') / 1024))
    }

    ########################
    # Get machine size depending on specified memory
    # Globals:
    #   None
    # Arguments:
    #   None
    # Flags:
    #   --memory - memory size (optional)
    # Returns:
    #   Detected instance size
    #########################
    get_machine_size() {
        local memory=""
        # Validate arguments
        while [[ "$#" -gt 0 ]]; do
            case "$1" in
            --memory)
                shift
                memory="${1:?missing memory}"
                ;;
            *)
                echo "Invalid command line flag $1" >&2
                return 1
                ;;
            esac
            shift
        done
        if [[ -z "$memory" ]]; then
            debug "Memory was not specified, detecting available memory automatically"
            memory="$(get_total_memory)"
        fi
        sanitized_memory=$(convert_to_mb "$memory")
        if [[ "$sanitized_memory" -gt 26000 ]]; then
            echo 2xlarge
        elif [[ "$sanitized_memory" -gt 13000 ]]; then
            echo xlarge
        elif [[ "$sanitized_memory" -gt 6000 ]]; then
            echo large
        elif [[ "$sanitized_memory" -gt 3000 ]]; then
            echo medium
        elif [[ "$sanitized_memory" -gt 1500 ]]; then
            echo small
        else
            echo micro
        fi
    }

    ########################
    # Get machine size depending on specified memory
    # Globals:
    #   None
    # Arguments:
    #   $1 - memory size (optional)
    # Returns:
    #   Detected instance size
    #########################
    get_supported_machine_sizes() {
        echo micro small medium large xlarge 2xlarge
    }

    ########################
    # Convert memory size from string to amount of megabytes (i.e. 2G -> 2048)
    # Globals:
    #   None
    # Arguments:
    #   $1 - memory size
    # Returns:
    #   Result of the conversion
    #########################
    convert_to_mb() {
        local amount="${1:-}"
        if [[ $amount =~ ^([0-9]+)(m|M|g|G) ]]; then
            size="${BASH_REMATCH[1]}"
            unit="${BASH_REMATCH[2]}"
            if [[ "$unit" = "g" || "$unit" = "G" ]]; then
                amount="$((size * 1024))"
            else
                amount="$size"
            fi
        fi
        echo "$amount"
    }

    #########################
    # Redirects output to /dev/null if debug mode is disabled
    # Globals:
    #   BITNAMI_DEBUG
    # Arguments:
    #   $@ - Command to execute
    # Returns:
    #   None
    #########################
    debug_execute() {
        if is_boolean_yes "${BITNAMI_DEBUG:-false}"; then
            "$@"
        else
            "$@" >/dev/null 2>&1
        fi
    }

    ########################
    # Retries a command a given number of times
    # Arguments:
    #   $1 - cmd (as a string)
    #   $2 - max retries. Default: 12
    #   $3 - sleep between retries (in seconds). Default: 5
    # Returns:
    #   Boolean
    #########################
    retry_while() {
        local cmd="${1:?cmd is missing}"
        local retries="${2:-12}"
        local sleep_time="${3:-5}"
        local return_value=1

        read -r -a command <<<"$cmd"
        for ((i = 1; i <= retries; i += 1)); do
            "${command[@]}" && return_value=0 && break
            sleep "$sleep_time"
        done
        return $return_value
    }

    ########################
    # Generate a random string
    # Arguments:
    #   -t|--type - String type (ascii, alphanumeric, numeric), defaults to ascii
    #   -c|--count - Number of characters, defaults to 32
    # Arguments:
    #   None
    # Returns:
    #   None
    # Returns:
    #   String
    #########################
    generate_random_string() {
        local type="ascii"
        local count="32"
        local filter
        local result
        # Validate arguments
        while [[ "$#" -gt 0 ]]; do
            case "$1" in
            -t | --type)
                shift
                type="$1"
                ;;
            -c | --count)
                shift
                count="$1"
                ;;
            *)
                echo "Invalid command line flag $1" >&2
                return 1
                ;;
            esac
            shift
        done
        # Validate type
        case "$type" in
        ascii)
            filter="[:print:]"
            ;;
        numeric)
            filter="0-9"
            ;;
        alphanumeric)
            filter="a-zA-Z0-9"
            ;;
        alphanumeric+special|special+alphanumeric)
            # Limit variety of special characters, so there is a higher chance of containing more alphanumeric characters
            # Special characters are harder to write, and it could impact the overall UX if most passwords are too complex
            filter='a-zA-Z0-9:@.,/+!='
            ;;
        *)
            echo "Invalid type ${type}" >&2
            return 1
            ;;
        esac
        # Obtain count + 10 lines from /dev/urandom to ensure that the resulting string has the expected size
        # Note there is a very small chance of strings starting with EOL character
        # Therefore, the higher amount of lines read, this will happen less frequently
        result="$(head -n "$((count + 10))" /dev/urandom | tr -dc "$filter" | head -c "$count")"
        echo "$result"
    }

    ########################
    # Create md5 hash from a string
    # Arguments:
    #   $1 - string
    # Returns:
    #   md5 hash - string
    #########################
    generate_md5_hash() {
        local -r str="${1:?missing input string}"
        echo -n "$str" | md5sum | awk '{print $1}'
    }

    ########################
    # Create sha1 hash from a string
    # Arguments:
    #   $1 - string
    #   $2 - algorithm - 1 (default), 224, 256, 384, 512
    # Returns:
    #   sha1 hash - string
    #########################
    generate_sha_hash() {
        local -r str="${1:?missing input string}"
        local -r algorithm="${2:-1}"
        echo -n "$str" | "sha${algorithm}sum" | awk '{print $1}'
    }

    ########################
    # Converts a string to its hexadecimal representation
    # Arguments:
    #   $1 - string
    # Returns:
    #   hexadecimal representation of the string
    #########################
    convert_to_hex() {
        local -r str=${1:?missing input string}
        local -i iterator
        local char
        for ((iterator = 0; iterator < ${#str}; iterator++)); do
            char=${str:iterator:1}
            printf '%x' "'${char}"
        done
    }

    ########################
    # Get boot time
    # Globals:
    #   None
    # Arguments:
    #   None
    # Returns:
    #   Boot time metadata
    #########################
    get_boot_time() {
        stat /proc --format=%Y
    }

    ########################
    # Get machine ID
    # Globals:
    #   None
    # Arguments:
    #   None
    # Returns:
    #   Machine ID
    #########################
    get_machine_id() {
        local machine_id
        if [[ -f /etc/machine-id ]]; then
            machine_id="$(cat /etc/machine-id)"
        fi
        if [[ -z "$machine_id" ]]; then
            # Fallback to the boot-time, which will at least ensure a unique ID in the current session
            machine_id="$(get_boot_time)"
        fi
        echo "$machine_id"
    }

    ########################
    # Get the root partition's disk device ID (e.g. /dev/sda1)
    # Globals:
    #   None
    # Arguments:
    #   None
    # Returns:
    #   Root partition disk ID
    #########################
    get_disk_device_id() {
        local device_id=""
        if grep -q ^/dev /proc/mounts; then
            device_id="$(grep ^/dev /proc/mounts | awk '$2 == "/" { print $1 }' | tail -1)"
        fi
        # If it could not be autodetected, fallback to /dev/sda1 as a default
        if [[ -z "$device_id" || ! -b "$device_id" ]]; then
            device_id="/dev/sda1"
        fi
        echo "$device_id"
    }

    ########################
    # Get the root disk device ID (e.g. /dev/sda)
    # Globals:
    #   None
    # Arguments:
    #   None
    # Returns:
    #   Root disk ID
    #########################
    get_root_disk_device_id() {
        get_disk_device_id | sed -E 's/p?[0-9]+$//'
    }

    ########################
    # Get the root disk size in bytes
    # Globals:
    #   None
    # Arguments:
    #   None
    # Returns:
    #   Root disk size in bytes
    #########################
    get_root_disk_size() {
        fdisk -l "$(get_root_disk_device_id)" | grep 'Disk.*bytes' | sed -E 's/.*, ([0-9]+) bytes,.*/\1/' || true
    }

    ########################
    # Run command as a specific user and group (optional)
    # Arguments:
    #   $1 - USER(:GROUP) to switch to
    #   $2..$n - command to execute
    # Returns:
    #   Exit code of the specified command
    #########################
    run_as_user() {
        run_chroot "$@"
    }

    ########################
    # Execute command as a specific user and group (optional),
    # replacing the current process image
    # Arguments:
    #   $1 - USER(:GROUP) to switch to
    #   $2..$n - command to execute
    # Returns:
    #   Exit code of the specified command
    #########################
    exec_as_user() {
        run_chroot --replace-process "$@"
    }

    ########################
    # Run a command using chroot
    # Arguments:
    #   $1 - USER(:GROUP) to switch to
    #   $2..$n - command to execute
    # Flags:
    #   -r | --replace-process - Replace the current process image (optional)
    # Returns:
    #   Exit code of the specified command
    #########################
    run_chroot() {
        local userspec
        local user
        local homedir
        local replace=false
        local -r cwd="$(pwd)"

        # Parse and validate flags
        while [[ "$#" -gt 0 ]]; do
            case "$1" in
                -r | --replace-process)
                    replace=true
                    ;;
                --)
                    shift
                    break
                    ;;
                -*)
                    stderr_print "unrecognized flag $1"
                    return 1
                    ;;
                *)
                    break
                    ;;
            esac
            shift
        done

        # Parse and validate arguments
        if [[ "$#" -lt 2 ]]; then
            echo "expected at least 2 arguments"
            return 1
        else
            userspec=$1
            shift

            # userspec can optionally include the group, so we parse the user
            user=$(echo "$userspec" | cut -d':' -f1)
        fi

        if ! am_i_root; then
            error "Could not switch to '${userspec}': Operation not permitted"
            return 1
        fi

        # Get the HOME directory for the user to switch, as chroot does
        # not properly update this env and some scripts rely on it
        homedir=$(eval echo "~${user}")
        if [[ ! -d $homedir ]]; then
            homedir="${HOME:-/}"
        fi

        # Obtaining value for "$@" indirectly in order to properly support shell parameter expansion
        if [[ "$replace" = true ]]; then
            exec chroot --userspec="$userspec" / bash -c "cd ${cwd}; export HOME=${homedir}; exec \"\$@\"" -- "$@"
        else
            chroot --userspec="$userspec" / bash -c "cd ${cwd}; export HOME=${homedir}; exec \"\$@\"" -- "$@"
        fi
    }
  libpersistence.sh: |
    #!/bin/bash
    # Copyright Broadcom, Inc. All Rights Reserved.
    # SPDX-License-Identifier: APACHE-2.0
    #
    # Bitnami persistence library
    # Used for bringing persistence capabilities to applications that don't have clear separation of data and logic

    # shellcheck disable=SC1091

    # Load Generic Libraries
    . /etc/redis_scripts/libfs.sh
    . /etc/redis_scripts/libos.sh
    . /etc/redis_scripts/liblog.sh
    . /etc/redis_scripts/libversion.sh

    # Functions

    ########################
    # Persist an application directory
    # Globals:
    #   BITNAMI_ROOT_DIR
    #   BITNAMI_VOLUME_DIR
    # Arguments:
    #   $1 - App folder name
    #   $2 - List of app files to persist
    # Returns:
    #   true if all steps succeeded, false otherwise
    #########################
    persist_app() {
        local -r app="${1:?missing app}"
        local -a files_to_restore
        read -r -a files_to_persist <<< "$(tr ',;:' ' ' <<< "$2")"
        local -r install_dir="${BITNAMI_ROOT_DIR}/${app}"
        local -r persist_dir="${BITNAMI_VOLUME_DIR}/${app}"
        # Persist the individual files
        if [[ "${#files_to_persist[@]}" -le 0 ]]; then
            warn "No files are configured to be persisted"
            return
        fi
        pushd "$install_dir" >/dev/null || exit
        local file_to_persist_relative file_to_persist_destination file_to_persist_destination_folder
        local -r tmp_file="/tmp/perms.acl"
        for file_to_persist in "${files_to_persist[@]}"; do
            if [[ ! -f "$file_to_persist" && ! -d "$file_to_persist" ]]; then
                error "Cannot persist '${file_to_persist}' because it does not exist"
                return 1
            fi
            file_to_persist_relative="$(relativize "$file_to_persist" "$install_dir")"
            file_to_persist_destination="${persist_dir}/${file_to_persist_relative}"
            file_to_persist_destination_folder="$(dirname "$file_to_persist_destination")"
            # Get original permissions for existing files, which will be applied later
            # Exclude the root directory with 'sed', to avoid issues when copying the entirety of it to a volume
            getfacl -R "$file_to_persist_relative" | sed -E '/# file: (\..+|[^.])/,$!d' > "$tmp_file"
            # Copy directories to the volume
            ensure_dir_exists "$file_to_persist_destination_folder"
            cp -Lr --preserve=links "$file_to_persist_relative" "$file_to_persist_destination_folder"
            # Restore permissions
            pushd "$persist_dir" >/dev/null || exit
            if am_i_root; then
                setfacl --restore="$tmp_file"
            else
                # When running as non-root, don't change ownership
                setfacl --restore=<(grep -E -v '^# (owner|group):' "$tmp_file")
            fi
            popd >/dev/null || exit
        done
        popd >/dev/null || exit
        rm -f "$tmp_file"
        # Install the persisted files into the installation directory, via symlinks
        restore_persisted_app "$@"
    }

    ########################
    # Restore a persisted application directory
    # Globals:
    #   BITNAMI_ROOT_DIR
    #   BITNAMI_VOLUME_DIR
    #   FORCE_MAJOR_UPGRADE
    # Arguments:
    #   $1 - App folder name
    #   $2 - List of app files to restore
    # Returns:
    #   true if all steps succeeded, false otherwise
    #########################
    restore_persisted_app() {
        local -r app="${1:?missing app}"
        local -a files_to_restore
        read -r -a files_to_restore <<< "$(tr ',;:' ' ' <<< "$2")"
        local -r install_dir="${BITNAMI_ROOT_DIR}/${app}"
        local -r persist_dir="${BITNAMI_VOLUME_DIR}/${app}"
        # Restore the individual persisted files
        if [[ "${#files_to_restore[@]}" -le 0 ]]; then
            warn "No persisted files are configured to be restored"
            return
        fi
        local file_to_restore_relative file_to_restore_origin file_to_restore_destination
        for file_to_restore in "${files_to_restore[@]}"; do
            file_to_restore_relative="$(relativize "$file_to_restore" "$install_dir")"
            # We use 'realpath --no-symlinks' to ensure that the case of '.' is covered and the directory is removed
            file_to_restore_origin="$(realpath --no-symlinks "${install_dir}/${file_to_restore_relative}")"
            file_to_restore_destination="$(realpath --no-symlinks "${persist_dir}/${file_to_restore_relative}")"
            rm -rf "$file_to_restore_origin"
            ln -sfn "$file_to_restore_destination" "$file_to_restore_origin"
        done
    }

    ########################
    # Check if an application directory was already persisted
    # Globals:
    #   BITNAMI_VOLUME_DIR
    # Arguments:
    #   $1 - App folder name
    # Returns:
    #   true if all steps succeeded, false otherwise
    #########################
    is_app_initialized() {
        local -r app="${1:?missing app}"
        local -r persist_dir="${BITNAMI_VOLUME_DIR}/${app}"
        if ! is_mounted_dir_empty "$persist_dir"; then
            true
        else
            false
        fi
    }
  libredissentinel.sh: |
    #!/bin/bash
    # Copyright Broadcom, Inc. All Rights Reserved.
    # SPDX-License-Identifier: APACHE-2.0
    #
    # Bitnami Redis Sentinel library

    # shellcheck disable=SC1091

    # Load Generic Libraries
    . /etc/redis_scripts/libfile.sh
    . /etc/redis_scripts/liblog.sh
    . /etc/redis_scripts/libnet.sh
    . /etc/redis_scripts/libos.sh
    . /etc/redis_scripts/libservice.sh
    . /etc/redis_scripts/libvalidations.sh

    # Functions

    ########################
    # Set a configuration setting value
    # Globals:
    #   REDIS_SENTINEL_CONF_FILE
    # Arguments:
    #   $1 - key
    #   $2 - value
    # Returns:
    #   None
    #########################
    redis_conf_set() {
        local key="${1:?missing key}"
        local value="${2:-}"

        # Sanitize inputs
        value="${value//\\/\\\\}"
        value="${value//&/\\&}"
        value="${value//\?/\\?}"
        [[ "$value" = "" ]] && value="\"$value\""

        if grep -q "^\s*$key .*" "$REDIS_SENTINEL_CONF_FILE"; then
            replace_in_file "$REDIS_SENTINEL_CONF_FILE" "^\s*${key} .*" "${key} ${value}" false
        else
            printf '\n%s %s' "$key" "$value" >>"$REDIS_SENTINEL_CONF_FILE"
        fi
    }

    ########################
    # Validate settings in REDIS_* env vars
    # Globals:
    #   REDIS_*
    # Arguments:
    #   None
    # Returns:
    #   None
    #########################
    redis_validate() {
        debug "Validating settings in REDIS_* env vars.."
        local error_code=0

        # Auxiliary functions
        print_validation_error() {
            error "$1"
            error_code=1
        }

        check_resolved_hostname() {
            if ! is_hostname_resolved "$1"; then
                warn "Hostname ${1} could not be resolved, this could lead to connection issues"
            fi
        }

        check_allowed_port() {
            local validate_port_args=()
            ! am_i_root && validate_port_args+=("-unprivileged")
            if ! err="$(validate_port "${validate_port_args[@]}" "${!1}")"; then
                print_validation_error "An invalid port was specified in the environment variable ${1}: ${err}"
            fi
        }

        [[ -w "$REDIS_SENTINEL_CONF_FILE" ]] || print_validation_error "The configuration file ${REDIS_SENTINEL_CONF_FILE} is not writable"

        is_positive_int "$REDIS_SENTINEL_QUORUM" || print_validation_error "Invalid quorum value (only positive integers allowed)"
        is_positive_int "$REDIS_SENTINEL_DOWN_AFTER_MILLISECONDS" || print_validation_error "Invalid down-after-milliseconds value (only positive integers allowed)"
        is_positive_int "$REDIS_SENTINEL_FAILOVER_TIMEOUT" || print_validation_error "Invalid failover-timeout value (only positive integers allowed)"

        if ! is_boolean_yes "$REDIS_SENTINEL_TLS_ENABLED" || [[ "$REDIS_SENTINEL_PORT_NUMBER" != "0" ]]; then
            check_allowed_port REDIS_SENTINEL_PORT_NUMBER
        fi
        check_resolved_hostname "$REDIS_MASTER_HOST"

        if is_boolean_yes "$REDIS_SENTINEL_TLS_ENABLED"; then
            if [[ "$REDIS_SENTINEL_PORT_NUMBER" == "$REDIS_SENTINEL_TLS_PORT_NUMBER" ]] && [[ "$REDIS_SENTINEL_PORT_NUMBER" != "26379" ]]; then
                # If both ports are assigned the same numbers and they are different to the default settings
                print_validation_error "Environment variables REDIS_SENTINEL_PORT_NUMBER and REDIS_SENTINEL_TLS_PORT_NUMBER point to the same port number (${REDIS_SENTINEL_PORT_NUMBER}). Change one of them or disable non-TLS traffic by setting REDIS_SENTINEL_PORT_NUMBER=0"
            fi
            if [[ -z "$REDIS_SENTINEL_TLS_CERT_FILE" ]]; then
                print_validation_error "You must provide a X.509 certificate in order to use TLS"
            elif [[ ! -f "$REDIS_SENTINEL_TLS_CERT_FILE" ]]; then
                print_validation_error "The X.509 certificate file in the specified path ${REDIS_SENTINEL_TLS_CERT_FILE} does not exist"
            fi
            if [[ -z "$REDIS_SENTINEL_TLS_KEY_FILE" ]]; then
                print_validation_error "You must provide a private key in order to use TLS"
            elif [[ ! -f "$REDIS_SENTINEL_TLS_KEY_FILE" ]]; then
                print_validation_error "The private key file in the specified path ${REDIS_SENTINEL_TLS_KEY_FILE} does not exist"
            fi
            if [[ -z "$REDIS_SENTINEL_TLS_CA_FILE" ]]; then
                print_validation_error "You must provide a CA X.509 certificate in order to use TLS"
            elif [[ ! -f "$REDIS_SENTINEL_TLS_CA_FILE" ]]; then
                print_validation_error "The CA X.509 certificate file in the specified path ${REDIS_SENTINEL_TLS_CA_FILE} does not exist"
            fi
            if [[ -n "$REDIS_SENTINEL_TLS_DH_PARAMS_FILE" ]] && [[ ! -f "$REDIS_SENTINEL_TLS_DH_PARAMS_FILE" ]]; then
                print_validation_error "The DH param file in the specified path ${REDIS_SENTINEL_TLS_DH_PARAMS_FILE} does not exist"
            fi
        fi

        [[ "$error_code" -eq 0 ]] || exit "$error_code"
    }

    ########################
    # Get Redis version
    # Arguments:
    #   None
    # Flags:
    #   --major - Whether to return only the major version (optional)
    #   --minor - Whether to return only the minor version (optional)
    #   --patch - Whether to return only the patch version (optional)
    # Returns:
    #   Redis version
    #########################
    redis_version() {
        local complete_version="true"
        local version

        # Parse optional CLI flags
        if [[ "$#" -gt 0 ]]; then
            case "$1" in
            --major)
                version="1"
                ;;
            --minor)
                version="2"
                ;;
            --patch)
                version="3"
                ;;
            *)
                echo "Invalid command line flag ${1}" >&2
                return 1
                ;;
            esac
            complete_version="false"
        fi
        if "$complete_version"; then
            "${REDIS_SENTINEL_BIN_DIR}/redis-cli" --version | grep -E -o "[0-9]+.[0-9]+.[0-9]+"
        else
            "${REDIS_SENTINEL_BIN_DIR}/redis-cli" --version | grep -E -o "[0-9]+.[0-9]+.[0-9]+" | grep -E -o "[0-9]" | awk "NR==${version}"
        fi
    }

    ########################
    # Check if redis is running
    # Globals:
    #   REDIS_BASE_DIR
    # Arguments:
    #   None
    # Returns:
    #   Boolean
    #########################
    is_redis_sentinel_running() {
        local pid
        pid="$(get_pid_from_file "$REDIS_SENTINEL_PID_FILE")"

        if [[ -z "$pid" ]]; then
            false
        else
            is_service_running "$pid"
        fi
    }

    ########################
    # Check if redis is not running
    # Globals:
    #   REDIS_BASE_DIR
    # Arguments:
    #   None
    # Returns:
    #   Boolean
    #########################
    is_redis_sentinel_not_running() {
        ! is_redis_sentinel_running
    }

    ########################
    # Ensure Redis is initialized
    # Globals:
    #   REDIS_*
    # Arguments:
    #   None
    # Returns:
    #   None
    #########################
    redis_initialize() {
        info "Initializing Redis Sentinel..."

        # Give the daemon user appropriate permissions
        if am_i_root; then
            for dir in "$REDIS_SENTINEL_CONF_DIR" "$REDIS_SENTINEL_LOG_DIR" "$REDIS_SENTINEL_TMP_DIR" "$REDIS_SENTINEL_VOLUME_DIR"; do
                chown -R "${REDIS_SENTINEL_DAEMON_USER}:${REDIS_SENTINEL_DAEMON_GROUP}" "$dir"
            done
        fi

        if [[ ! -f "${REDIS_SENTINEL_VOLUME_DIR}/conf/sentinel.conf" ]]; then
            info "Configuring Redis Sentinel..."

            [[ -z "$REDIS_SENTINEL_PASSWORD" ]] || redis_conf_set "requirepass" "$REDIS_SENTINEL_PASSWORD"

            # Master set
            # shellcheck disable=SC2153
            redis_conf_set "sentinel monitor" "${REDIS_MASTER_SET} ${REDIS_MASTER_HOST} ${REDIS_MASTER_PORT_NUMBER} ${REDIS_SENTINEL_QUORUM}"
            redis_conf_set "sentinel down-after-milliseconds" "${REDIS_MASTER_SET} ${REDIS_SENTINEL_DOWN_AFTER_MILLISECONDS}"
            redis_conf_set "sentinel failover-timeout" "${REDIS_MASTER_SET} ${REDIS_SENTINEL_FAILOVER_TIMEOUT}"
            redis_conf_set "sentinel parallel-syncs" "${REDIS_MASTER_SET} 1"
            [[ -z "$REDIS_MASTER_PASSWORD" ]] || redis_conf_set "sentinel auth-pass" "${REDIS_MASTER_SET} ${REDIS_MASTER_PASSWORD}"
            [[ -z "$REDIS_MASTER_USER" ]] || redis_conf_set "sentinel auth-user" "${REDIS_MASTER_SET} ${REDIS_MASTER_USER}"
            [[ -z "$REDIS_SENTINEL_ANNOUNCE_IP" ]] || redis_conf_set "sentinel announce-ip" "${REDIS_SENTINEL_ANNOUNCE_IP}"
            [[ -z "$REDIS_SENTINEL_ANNOUNCE_PORT" ]] || redis_conf_set "sentinel announce-port" "${REDIS_SENTINEL_ANNOUNCE_PORT}"
            # Sentinel's configuration was refactored for Redis 6.2 and hostname's support now has to be enabled using a configuration parameter
            if { [[ $(redis_version --major) -ge 6 ]] && [[ $(redis_version --minor) -ge 2 ]]; } || [[ $(redis_version --major) -ge 7 ]]; then
                redis_conf_set "sentinel resolve-hostnames" "${REDIS_SENTINEL_RESOLVE_HOSTNAMES}"
                redis_conf_set "sentinel announce-hostnames" "${REDIS_SENTINEL_ANNOUNCE_HOSTNAMES}"
            fi
            # This directive is only available in Redis 7
            [[ $(redis_version --major) -ge 7 ]] && redis_conf_set "SENTINEL master-reboot-down-after-period" "${REDIS_MASTER_SET} ${REDIS_SENTINEL_MASTER_REBOOT_DOWN_AFTER_PERIOD}"

            # Sentinel Configuration (maybe overwritten by more specific init blocks like TLS configuration)
            redis_conf_set port "$REDIS_SENTINEL_PORT_NUMBER"

            # TLS configuration
            if is_boolean_yes "$REDIS_SENTINEL_TLS_ENABLED"; then
                if { [[ "$REDIS_SENTINEL_PORT_NUMBER" == "26379" ]] || [[ "$REDIS_SENTINEL_PORT_NUMBER" == "0" ]]; } && [[ "$REDIS_SENTINEL_TLS_PORT_NUMBER" == "26379" ]]; then
                    # If both ports are set to default values, enable TLS traffic only
                    redis_conf_set port 0
                    redis_conf_set tls-port "$REDIS_SENTINEL_TLS_PORT_NUMBER"
                else
                    # Different ports were specified
                    redis_conf_set port "$REDIS_SENTINEL_PORT_NUMBER"
                    redis_conf_set tls-port "$REDIS_SENTINEL_TLS_PORT_NUMBER"
                fi
                redis_conf_set tls-cert-file "$REDIS_SENTINEL_TLS_CERT_FILE"
                redis_conf_set tls-key-file "$REDIS_SENTINEL_TLS_KEY_FILE"
                redis_conf_set tls-ca-cert-file "$REDIS_SENTINEL_TLS_CA_FILE"
                [[ -n "$REDIS_SENTINEL_TLS_DH_PARAMS_FILE" ]] && redis_conf_set tls-dh-params-file "$REDIS_SENTINEL_TLS_DH_PARAMS_FILE"
                redis_conf_set tls-auth-clients "$REDIS_SENTINEL_TLS_AUTH_CLIENTS"
                redis_conf_set tls-replication yes
            fi

            cp -pf "$REDIS_SENTINEL_CONF_FILE" "${REDIS_SENTINEL_VOLUME_DIR}/conf/sentinel.conf"
        else
            info "Persisted files detected, restoring..."
        fi

        rm -rf "$REDIS_SENTINEL_CONF_DIR"
        ln -sf "${REDIS_SENTINEL_VOLUME_DIR}/conf" "$REDIS_SENTINEL_CONF_DIR"
    }
  libservice.sh: |
    #!/bin/bash
    # Copyright Broadcom, Inc. All Rights Reserved.
    # SPDX-License-Identifier: APACHE-2.0
    #
    # Library for managing services

    # shellcheck disable=SC1091

    # Load Generic Libraries
    . /etc/redis_scripts/libvalidations.sh
    . /etc/redis_scripts/liblog.sh

    # Functions

    ########################
    # Read the provided pid file and returns a PID
    # Arguments:
    #   $1 - Pid file
    # Returns:
    #   PID
    #########################
    get_pid_from_file() {
        local pid_file="${1:?pid file is missing}"

        if [[ -f "$pid_file" ]]; then
            if [[ -n "$(< "$pid_file")" ]] && [[ "$(< "$pid_file")" -gt 0 ]]; then
                echo "$(< "$pid_file")"
            fi
        fi
    }

    ########################
    # Check if a provided PID corresponds to a running service
    # Arguments:
    #   $1 - PID
    # Returns:
    #   Boolean
    #########################
    is_service_running() {
        local pid="${1:?pid is missing}"

        kill -0 "$pid" 2>/dev/null
    }

    ########################
    # Stop a service by sending a termination signal to its pid
    # Arguments:
    #   $1 - Pid file
    #   $2 - Signal number (optional)
    # Returns:
    #   None
    #########################
    stop_service_using_pid() {
        local pid_file="${1:?pid file is missing}"
        local signal="${2:-}"
        local pid

        pid="$(get_pid_from_file "$pid_file")"
        [[ -z "$pid" ]] || ! is_service_running "$pid" && return

        if [[ -n "$signal" ]]; then
            kill "-${signal}" "$pid"
        else
            kill "$pid"
        fi

        local counter=10
        while [[ "$counter" -ne 0 ]] && is_service_running "$pid"; do
            sleep 1
            counter=$((counter - 1))
        done
    }

    ########################
    # Start cron daemon
    # Arguments:
    #   None
    # Returns:
    #   true if started correctly, false otherwise
    #########################
    cron_start() {
        if [[ -x "/usr/sbin/cron" ]]; then
            /usr/sbin/cron
        elif [[ -x "/usr/sbin/crond" ]]; then
            /usr/sbin/crond
        else
            false
        fi
    }

    ########################
    # Generate a cron configuration file for a given service
    # Arguments:
    #   $1 - Service name
    #   $2 - Command
    # Flags:
    #   --run-as - User to run as (default: root)
    #   --schedule - Cron schedule configuration (default: * * * * *)
    # Returns:
    #   None
    #########################
    generate_cron_conf() {
        local service_name="${1:?service name is missing}"
        local cmd="${2:?command is missing}"
        local run_as="root"
        local schedule="* * * * *"
        local clean="true"

        # Parse optional CLI flags
        shift 2
        while [[ "$#" -gt 0 ]]; do
            case "$1" in
                --run-as)
                    shift
                    run_as="$1"
                    ;;
                --schedule)
                    shift
                    schedule="$1"
                    ;;
                --no-clean)
                    clean="false"
                    ;;
                *)
                    echo "Invalid command line flag ${1}" >&2
                    return 1
                    ;;
            esac
            shift
        done

        mkdir -p /etc/cron.d
        if "$clean"; then
            cat > "/etc/cron.d/${service_name}" <<EOF
    # Copyright Broadcom, Inc. All Rights Reserved.
    # SPDX-License-Identifier: APACHE-2.0

    ${schedule} ${run_as} ${cmd}
    EOF
        else
            echo "${schedule} ${run_as} ${cmd}" >> /etc/cron.d/"$service_name"
        fi
    }

    ########################
    # Remove a cron configuration file for a given service
    # Arguments:
    #   $1 - Service name
    # Returns:
    #   None
    #########################
    remove_cron_conf() {
        local service_name="${1:?service name is missing}"
        local cron_conf_dir="/etc/monit/conf.d"
        rm -f "${cron_conf_dir}/${service_name}"
    }

    ########################
    # Generate a monit configuration file for a given service
    # Arguments:
    #   $1 - Service name
    #   $2 - Pid file
    #   $3 - Start command
    #   $4 - Stop command
    # Flags:
    #   --disable - Whether to disable the monit configuration
    # Returns:
    #   None
    #########################
    generate_monit_conf() {
        local service_name="${1:?service name is missing}"
        local pid_file="${2:?pid file is missing}"
        local start_command="${3:?start command is missing}"
        local stop_command="${4:?stop command is missing}"
        local monit_conf_dir="/etc/monit/conf.d"
        local disabled="no"

        # Parse optional CLI flags
        shift 4
        while [[ "$#" -gt 0 ]]; do
            case "$1" in
                --disable)
                    disabled="yes"
                    ;;
                *)
                    echo "Invalid command line flag ${1}" >&2
                    return 1
                    ;;
            esac
            shift
        done

        is_boolean_yes "$disabled" && conf_suffix=".disabled"
        mkdir -p "$monit_conf_dir"
        cat > "${monit_conf_dir}/${service_name}.conf${conf_suffix:-}" <<EOF
    # Copyright Broadcom, Inc. All Rights Reserved.
    # SPDX-License-Identifier: APACHE-2.0

    check process ${service_name}
      with pidfile "${pid_file}"
      start program = "${start_command}" with timeout 90 seconds
      stop program = "${stop_command}" with timeout 90 seconds
    EOF
    }

    ########################
    # Remove a monit configuration file for a given service
    # Arguments:
    #   $1 - Service name
    # Returns:
    #   None
    #########################
    remove_monit_conf() {
        local service_name="${1:?service name is missing}"
        local monit_conf_dir="/etc/monit/conf.d"
        rm -f "${monit_conf_dir}/${service_name}.conf"
    }

    ########################
    # Generate a logrotate configuration file
    # Arguments:
    #   $1 - Service name
    #   $2 - Log files pattern
    # Flags:
    #   --period - Period
    #   --rotations - Number of rotations to store
    #   --extra - Extra options (Optional)
    # Returns:
    #   None
    #########################
    generate_logrotate_conf() {
        local service_name="${1:?service name is missing}"
        local log_path="${2:?log path is missing}"
        local period="weekly"
        local rotations="150"
        local extra=""
        local logrotate_conf_dir="/etc/logrotate.d"
        local var_name
        # Parse optional CLI flags
        shift 2
        while [[ "$#" -gt 0 ]]; do
            case "$1" in
                --period|--rotations|--extra)
                    var_name="$(echo "$1" | sed -e "s/^--//" -e "s/-/_/g")"
                    shift
                    declare "$var_name"="${1:?"$var_name" is missing}"
                    ;;
                *)
                    echo "Invalid command line flag ${1}" >&2
                    return 1
                    ;;
            esac
            shift
        done

        mkdir -p "$logrotate_conf_dir"
        cat <<EOF | sed '/^\s*$/d' > "${logrotate_conf_dir}/${service_name}"
    # Copyright Broadcom, Inc. All Rights Reserved.
    # SPDX-License-Identifier: APACHE-2.0

    ${log_path} {
      ${period}
      rotate ${rotations}
      dateext
      compress
      copytruncate
      missingok
    $(indent "$extra" 2)
    }
    EOF
    }

    ########################
    # Remove a logrotate configuration file
    # Arguments:
    #   $1 - Service name
    # Returns:
    #   None
    #########################
    remove_logrotate_conf() {
        local service_name="${1:?service name is missing}"
        local logrotate_conf_dir="/etc/logrotate.d"
        rm -f "${logrotate_conf_dir}/${service_name}"
    }

    ########################
    # Generate a Systemd configuration file
    # Arguments:
    #   $1 - Service name
    # Flags:
    #   --custom-service-content - Custom content to add to the [service] block
    #   --environment - Environment variable to define (multiple --environment options may be passed)
    #   --environment-file - Text file with environment variables (multiple --environment-file options may be passed)
    #   --exec-start - Start command (required)
    #   --exec-start-pre - Pre-start command (optional)
    #   --exec-start-post - Post-start command (optional)
    #   --exec-stop - Stop command (optional)
    #   --exec-reload - Reload command (optional)
    #   --group - System group to start the service with
    #   --name - Service full name (e.g. Apache HTTP Server, defaults to $1)
    #   --restart - When to restart the Systemd service after being stopped (defaults to always)
    #   --pid-file - Service PID file
    #   --standard-output - File where to print stdout output
    #   --standard-error - File where to print stderr output
    #   --success-exit-status - Exit code that indicates a successful shutdown
    #   --type - Systemd unit type (defaults to forking)
    #   --user - System user to start the service with
    #   --working-directory - Working directory at which to start the service
    # Returns:
    #   None
    #########################
    generate_systemd_conf() {
        local -r service_name="${1:?service name is missing}"
        local -r systemd_units_dir="/etc/systemd/system"
        local -r service_file="${systemd_units_dir}/bitnami.${service_name}.service"
        # Default values
        local name="$service_name"
        local type="forking"
        local user=""
        local group=""
        local environment=""
        local environment_file=""
        local exec_start=""
        local exec_start_pre=""
        local exec_start_post=""
        local exec_stop=""
        local exec_reload=""
        local restart="always"
        local pid_file=""
        local standard_output="journal"
        local standard_error=""
        local limits_content=""
        local success_exit_status=""
        local custom_service_content=""
        local working_directory=""
        # Parse CLI flags
        shift
        while [[ "$#" -gt 0 ]]; do
            case "$1" in
                --name \
                | --type \
                | --user \
                | --group \
                | --exec-start \
                | --exec-stop \
                | --exec-reload \
                | --restart \
                | --pid-file \
                | --standard-output \
                | --standard-error \
                | --success-exit-status \
                | --custom-service-content \
                | --working-directory \
                )
                    var_name="$(echo "$1" | sed -e "s/^--//" -e "s/-/_/g")"
                    shift
                    declare "$var_name"="${1:?"${var_name} value is missing"}"
                    ;;
                --limit-*)
                    [[ -n "$limits_content" ]] && limits_content+=$'\n'
                    var_name="${1//--limit-}"
                    shift
                    limits_content+="Limit${var_name^^}=${1:?"--limit-${var_name} value is missing"}"
                    ;;
                --exec-start-pre)
                    shift
                    [[ -n "$exec_start_pre" ]] && exec_start_pre+=$'\n'
                    exec_start_pre+="ExecStartPre=${1:?"--exec-start-pre value is missing"}"
                    ;;
                --exec-start-post)
                    shift
                    [[ -n "$exec_start_post" ]] && exec_start_post+=$'\n'
                    exec_start_post+="ExecStartPost=${1:?"--exec-start-post value is missing"}"
                    ;;
                --environment)
                    shift
                    # It is possible to add multiple environment lines
                    [[ -n "$environment" ]] && environment+=$'\n'
                    environment+="Environment=${1:?"--environment value is missing"}"
                    ;;
                --environment-file)
                    shift
                    # It is possible to add multiple environment-file lines
                    [[ -n "$environment_file" ]] && environment_file+=$'\n'
                    environment_file+="EnvironmentFile=${1:?"--environment-file value is missing"}"
                    ;;
                *)
                    echo "Invalid command line flag ${1}" >&2
                    return 1
                    ;;
            esac
            shift
        done
        # Validate inputs
        local error="no"
        if [[ -z "$exec_start" ]]; then
            error "The --exec-start option is required"
            error="yes"
        fi
        if [[ "$error" != "no" ]]; then
            return 1
        fi
        # Generate the Systemd unit
        cat > "$service_file" <<EOF
    # Copyright Broadcom, Inc. All Rights Reserved.
    # SPDX-License-Identifier: APACHE-2.0

    [Unit]
    Description=Bitnami service for ${name}
    # Starting/stopping the main bitnami service should cause the same effect for this service
    PartOf=bitnami.service

    [Service]
    Type=${type}
    EOF
        if [[ -n "$working_directory" ]]; then
            cat >> "$service_file" <<< "WorkingDirectory=${working_directory}"
        fi
        if [[ -n "$exec_start_pre" ]]; then
            # This variable may contain multiple ExecStartPre= directives
            cat >> "$service_file" <<< "$exec_start_pre"
        fi
        if [[ -n "$exec_start" ]]; then
            cat >> "$service_file" <<< "ExecStart=${exec_start}"
        fi
        if [[ -n "$exec_start_post" ]]; then
            # This variable may contain multiple ExecStartPost= directives
            cat >> "$service_file" <<< "$exec_start_post"
        fi
        # Optional stop and reload commands
        if [[ -n "$exec_stop" ]]; then
            cat >> "$service_file" <<< "ExecStop=${exec_stop}"
        fi
        if [[ -n "$exec_reload" ]]; then
            cat >> "$service_file" <<< "ExecReload=${exec_reload}"
        fi
        # User and group
        if [[ -n "$user" ]]; then
            cat >> "$service_file" <<< "User=${user}"
        fi
        if [[ -n "$group" ]]; then
            cat >> "$service_file" <<< "Group=${group}"
        fi
        # PID file allows to determine if the main process is running properly (for Restart=always)
        if [[ -n "$pid_file" ]]; then
            cat >> "$service_file" <<< "PIDFile=${pid_file}"
        fi
        if [[ -n "$restart" ]]; then
            cat >> "$service_file" <<< "Restart=${restart}"
        fi
        # Environment flags
        if [[ -n "$environment" ]]; then
            # This variable may contain multiple Environment= directives
            cat >> "$service_file" <<< "$environment"
        fi
        if [[ -n "$environment_file" ]]; then
            # This variable may contain multiple EnvironmentFile= directives
            cat >> "$service_file" <<< "$environment_file"
        fi
        # Logging
        if [[ -n "$standard_output" ]]; then
            cat >> "$service_file" <<< "StandardOutput=${standard_output}"
        fi
        if [[ -n "$standard_error" ]]; then
            cat >> "$service_file" <<< "StandardError=${standard_error}"
        fi
        if [[ -n "$custom_service_content" ]]; then
            # This variable may contain multiple miscellaneous directives
            cat >> "$service_file" <<< "$custom_service_content"
        fi
        if [[ -n "$success_exit_status" ]]; then
            cat >> "$service_file" <<EOF
    # When the process receives a SIGTERM signal, it exits with code ${success_exit_status}
    SuccessExitStatus=${success_exit_status}
    EOF
        fi
        cat >> "$service_file" <<EOF
    # Optimizations
    TimeoutStartSec=2min
    TimeoutStopSec=30s
    IgnoreSIGPIPE=no
    KillMode=mixed
    EOF
        if [[ -n "$limits_content" ]]; then
            cat >> "$service_file" <<EOF
    # Limits
    ${limits_content}
    EOF
        fi
        cat >> "$service_file" <<EOF

    [Install]
    # Enabling/disabling the main bitnami service should cause the same effect for this service
    WantedBy=bitnami.service
    EOF
    }
  libvalidations.sh: |
    #!/bin/bash
    # Copyright Broadcom, Inc. All Rights Reserved.
    # SPDX-License-Identifier: APACHE-2.0
    #
    # Validation functions library

    # shellcheck disable=SC1091,SC2086

    # Load Generic Libraries
    . /etc/redis_scripts/liblog.sh

    # Functions

    ########################
    # Check if the provided argument is an integer
    # Arguments:
    #   $1 - Value to check
    # Returns:
    #   Boolean
    #########################
    is_int() {
        local -r int="${1:?missing value}"
        if [[ "$int" =~ ^-?[0-9]+ ]]; then
            true
        else
            false
        fi
    }

    ########################
    # Check if the provided argument is a positive integer
    # Arguments:
    #   $1 - Value to check
    # Returns:
    #   Boolean
    #########################
    is_positive_int() {
        local -r int="${1:?missing value}"
        if is_int "$int" && (( "${int}" >= 0 )); then
            true
        else
            false
        fi
    }

    ########################
    # Check if the provided argument is a boolean or is the string 'yes/true'
    # Arguments:
    #   $1 - Value to check
    # Returns:
    #   Boolean
    #########################
    is_boolean_yes() {
        local -r bool="${1:-}"
        # comparison is performed without regard to the case of alphabetic characters
        shopt -s nocasematch
        if [[ "$bool" = 1 || "$bool" =~ ^(yes|true)$ ]]; then
            true
        else
            false
        fi
    }

    ########################
    # Check if the provided argument is a boolean yes/no value
    # Arguments:
    #   $1 - Value to check
    # Returns:
    #   Boolean
    #########################
    is_yes_no_value() {
        local -r bool="${1:-}"
        if [[ "$bool" =~ ^(yes|no)$ ]]; then
            true
        else
            false
        fi
    }

    ########################
    # Check if the provided argument is a boolean true/false value
    # Arguments:
    #   $1 - Value to check
    # Returns:
    #   Boolean
    #########################
    is_true_false_value() {
        local -r bool="${1:-}"
        if [[ "$bool" =~ ^(true|false)$ ]]; then
            true
        else
            false
        fi
    }

    ########################
    # Check if the provided argument is a boolean 1/0 value
    # Arguments:
    #   $1 - Value to check
    # Returns:
    #   Boolean
    #########################
    is_1_0_value() {
        local -r bool="${1:-}"
        if [[ "$bool" =~ ^[10]$ ]]; then
            true
        else
            false
        fi
    }

    ########################
    # Check if the provided argument is an empty string or not defined
    # Arguments:
    #   $1 - Value to check
    # Returns:
    #   Boolean
    #########################
    is_empty_value() {
        local -r val="${1:-}"
        if [[ -z "$val" ]]; then
            true
        else
            false
        fi
    }

    ########################
    # Validate if the provided argument is a valid port
    # Arguments:
    #   $1 - Port to validate
    # Returns:
    #   Boolean and error message
    #########################
    validate_port() {
        local value
        local unprivileged=0

        # Parse flags
        while [[ "$#" -gt 0 ]]; do
            case "$1" in
                -unprivileged)
                    unprivileged=1
                    ;;
                --)
                    shift
                    break
                    ;;
                -*)
                    stderr_print "unrecognized flag $1"
                    return 1
                    ;;
                *)
                    break
                    ;;
            esac
            shift
        done

        if [[ "$#" -gt 1 ]]; then
            echo "too many arguments provided"
            return 2
        elif [[ "$#" -eq 0 ]]; then
            stderr_print "missing port argument"
            return 1
        else
            value=$1
        fi

        if [[ -z "$value" ]]; then
            echo "the value is empty"
            return 1
        else
            if ! is_int "$value"; then
                echo "value is not an integer"
                return 2
            elif [[ "$value" -lt 0 ]]; then
                echo "negative value provided"
                return 2
            elif [[ "$value" -gt 65535 ]]; then
                echo "requested port is greater than 65535"
                return 2
            elif [[ "$unprivileged" = 1 && "$value" -lt 1024 ]]; then
                echo "privileged port requested"
                return 3
            fi
        fi
    }

    ########################
    # Validate if the provided argument is a valid IPv6 address
    # Arguments:
    #   $1 - IP to validate
    # Returns:
    #   Boolean
    #########################
    validate_ipv6() {
        local ip="${1:?ip is missing}"
        local stat=1
        local full_address_regex='^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$'
        local short_address_regex='^((([0-9a-fA-F]{1,4}:){0,6}[0-9a-fA-F]{1,4}){0,6}::(([0-9a-fA-F]{1,4}:){0,6}[0-9a-fA-F]{1,4}){0,6})$'

        if [[ $ip =~ $full_address_regex || $ip =~ $short_address_regex || $ip == "::" ]]; then
            stat=0
        fi
        return $stat
    }

    ########################
    # Validate if the provided argument is a valid IPv4 address
    # Arguments:
    #   $1 - IP to validate
    # Returns:
    #   Boolean
    #########################
    validate_ipv4() {
        local ip="${1:?ip is missing}"
        local stat=1

        if [[ $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
            read -r -a ip_array <<< "$(tr '.' ' ' <<< "$ip")"
            [[ ${ip_array[0]} -le 255 && ${ip_array[1]} -le 255 \
                && ${ip_array[2]} -le 255 && ${ip_array[3]} -le 255 ]]
            stat=$?
        fi
        return $stat
    }

    ########################
    # Validate if the provided argument is a valid IPv4 or IPv6 address
    # Arguments:
    #   $1 - IP to validate
    # Returns:
    #   Boolean
    #########################
    validate_ip() {
        local ip="${1:?ip is missing}"
        local stat=1

        if validate_ipv4 "$ip"; then
            stat=0
        else
            stat=$(validate_ipv6 "$ip")
        fi
        return $stat
    }

    ########################
    # Validate a string format
    # Arguments:
    #   $1 - String to validate
    # Returns:
    #   Boolean
    #########################
    validate_string() {
        local string
        local min_length=-1
        local max_length=-1

        # Parse flags
        while [ "$#" -gt 0 ]; do
            case "$1" in
                -min-length)
                    shift
                    min_length=${1:-}
                    ;;
                -max-length)
                    shift
                    max_length=${1:-}
                    ;;
                --)
                    shift
                    break
                    ;;
                -*)
                    stderr_print "unrecognized flag $1"
                    return 1
                    ;;
                *)
                    break
                    ;;
            esac
            shift
        done

        if [ "$#" -gt 1 ]; then
            stderr_print "too many arguments provided"
            return 2
        elif [ "$#" -eq 0 ]; then
            stderr_print "missing string"
            return 1
        else
            string=$1
        fi

        if [[ "$min_length" -ge 0 ]] && [[ "${#string}" -lt "$min_length" ]]; then
            echo "string length is less than $min_length"
            return 1
        fi
        if [[ "$max_length" -ge 0 ]] && [[ "${#string}" -gt "$max_length" ]]; then
            echo "string length is great than $max_length"
            return 1
        fi
    }
  libversion.sh: |
    #!/bin/bash
    # Copyright Broadcom, Inc. All Rights Reserved.
    # SPDX-License-Identifier: APACHE-2.0
    #
    # Library for managing versions strings

    # shellcheck disable=SC1091

    # Load Generic Libraries
    . /etc/redis_scripts/liblog.sh

    # Functions
    ########################
    # Gets semantic version
    # Arguments:
    #   $1 - version: string to extract major.minor.patch
    #   $2 - section: 1 to extract major, 2 to extract minor, 3 to extract patch
    # Returns:
    #   array with the major, minor and release
    #########################
    get_sematic_version () {
        local version="${1:?version is required}"
        local section="${2:?section is required}"
        local -a version_sections

        #Regex to parse versions: x.y.z
        local -r regex='([0-9]+)(\.([0-9]+)(\.([0-9]+))?)?'

        if [[ "$version" =~ $regex ]]; then
            local i=1
            local j=1
            local n=${#BASH_REMATCH[*]}

            while [[ $i -lt $n ]]; do
                if [[ -n "${BASH_REMATCH[$i]}" ]] && [[ "${BASH_REMATCH[$i]:0:1}" != '.' ]];  then
                    version_sections[j]="${BASH_REMATCH[$i]}"
                    ((j++))
                fi
                ((i++))
            done

            local number_regex='^[0-9]+$'
            if [[ "$section" =~ $number_regex ]] && (( section > 0 )) && (( section <= 3 )); then
                echo "${version_sections[$section]}"
                return
            else
                stderr_print "Section allowed values are: 1, 2, and 3"
                return 1
            fi
        fi
    }
  libwebserver.sh: |
    #!/bin/bash
    # Copyright Broadcom, Inc. All Rights Reserved.
    # SPDX-License-Identifier: APACHE-2.0
    #
    # Bitnami web server handler library

    # shellcheck disable=SC1090,SC1091

    # Load generic libraries
    . /etc/redis_scripts/liblog.sh

    ########################
    # Execute a command (or list of commands) with the web server environment and library loaded
    # Globals:
    #   *
    # Arguments:
    #   None
    # Returns:
    #   None
    #########################
    web_server_execute() {
        local -r web_server="${1:?missing web server}"
        shift
        # Run program in sub-shell to avoid web server environment getting loaded when not necessary
        (
            . "/etc/redis_scripts/lib${web_server}.sh"
            . "/etc/redis_scripts/${web_server}-env.sh"
            "$@"
        )
    }

    ########################
    # Prints the list of enabled web servers
    # Globals:
    #   None
    # Arguments:
    #   None
    # Returns:
    #   None
    #########################
    web_server_list() {
        local -r -a supported_web_servers=(apache nginx)
        local -a existing_web_servers=()
        for web_server in "${supported_web_servers[@]}"; do
            [[ -f "/etc/redis_scripts/${web_server}-env.sh" ]] && existing_web_servers+=("$web_server")
        done
        echo "${existing_web_servers[@]:-}"
    }

    ########################
    # Prints the currently-enabled web server type (only one, in order of preference)
    # Globals:
    #   None
    # Arguments:
    #   None
    # Returns:
    #   None
    #########################
    web_server_type() {
        local -a web_servers
        read -r -a web_servers <<< "$(web_server_list)"
        echo "${web_servers[0]:-}"
    }

    ########################
    # Validate that a supported web server is configured
    # Globals:
    #   None
    # Arguments:
    #   None
    # Returns:
    #   None
    #########################
    web_server_validate() {
        local error_code=0
        local supported_web_servers=("apache" "nginx")

        # Auxiliary functions
        print_validation_error() {
            error "$1"
            error_code=1
        }

        if [[ -z "$(web_server_type)" || ! " ${supported_web_servers[*]} " == *" $(web_server_type) "* ]]; then
            print_validation_error "Could not detect any supported web servers. It must be one of: ${supported_web_servers[*]}"
        elif ! web_server_execute "$(web_server_type)" type -t "is_$(web_server_type)_running" >/dev/null; then
            print_validation_error "Could not load the $(web_server_type) web server library from /opt/bitnami/scripts. Check that it exists and is readable."
        fi

        return "$error_code"
    }

    ########################
    # Check whether the web server is running
    # Globals:
    #   *
    # Arguments:
    #   None
    # Returns:
    #   true if the web server is running, false otherwise
    #########################
    is_web_server_running() {
        "is_$(web_server_type)_running"
    }

    ########################
    # Start web server
    # Globals:
    #   *
    # Arguments:
    #   None
    # Returns:
    #   None
    #########################
    web_server_start() {
        info "Starting $(web_server_type) in background"
        if [[ "${BITNAMI_SERVICE_MANAGER:-}" = "systemd" ]]; then
            systemctl start "bitnami.$(web_server_type).service"
        else
            "${BITNAMI_ROOT_DIR}/scripts/$(web_server_type)/start.sh"
        fi
    }

    ########################
    # Stop web server
    # Globals:
    #   *
    # Arguments:
    #   None
    # Returns:
    #   None
    #########################
    web_server_stop() {
        info "Stopping $(web_server_type)"
        if [[ "${BITNAMI_SERVICE_MANAGER:-}" = "systemd" ]]; then
            systemctl stop "bitnami.$(web_server_type).service"
        else
            "${BITNAMI_ROOT_DIR}/scripts/$(web_server_type)/stop.sh"
        fi
    }

    ########################
    # Restart web server
    # Globals:
    #   *
    # Arguments:
    #   None
    # Returns:
    #   None
    #########################
    web_server_restart() {
        info "Restarting $(web_server_type)"
        if [[ "${BITNAMI_SERVICE_MANAGER:-}" = "systemd" ]]; then
            systemctl restart "bitnami.$(web_server_type).service"
        else
            "${BITNAMI_ROOT_DIR}/scripts/$(web_server_type)/restart.sh"
        fi
    }

    ########################
    # Reload web server
    # Globals:
    #   *
    # Arguments:
    #   None
    # Returns:
    #   None
    #########################
    web_server_reload() {
        if [[ "${BITNAMI_SERVICE_MANAGER:-}" = "systemd" ]]; then
            systemctl reload "bitnami.$(web_server_type).service"
        else
            "${BITNAMI_ROOT_DIR}/scripts/$(web_server_type)/reload.sh"
        fi
    }

    ########################
    # Ensure a web server application configuration exists (i.e. Apache virtual host format or NGINX server block)
    # It serves as a wrapper for the specific web server function
    # Globals:
    #   *
    # Arguments:
    #   $1 - App name
    # Flags:
    #   --type - Application type, which has an effect on which configuration template to use
    #   --hosts - Host listen addresses
    #   --server-name - Server name
    #   --server-aliases - Server aliases
    #   --allow-remote-connections - Whether to allow remote connections or to require local connections
    #   --disable - Whether to render server configurations with a .disabled prefix
    #   --disable-http - Whether to render the app's HTTP server configuration with a .disabled prefix
    #   --disable-https - Whether to render the app's HTTPS server configuration with a .disabled prefix
    #   --http-port - HTTP port number
    #   --https-port - HTTPS port number
    #   --document-root - Path to document root directory
    # Apache-specific flags:
    #   --apache-additional-configuration - Additional vhost configuration (no default)
    #   --apache-additional-http-configuration - Additional HTTP vhost configuration (no default)
    #   --apache-additional-https-configuration - Additional HTTPS vhost configuration (no default)
    #   --apache-before-vhost-configuration - Configuration to add before the <VirtualHost> directive (no default)
    #   --apache-allow-override - Whether to allow .htaccess files (only allowed when --move-htaccess is set to 'no' and type is not defined)
    #   --apache-extra-directory-configuration - Extra configuration for the document root directory
    #   --apache-proxy-address - Address where to proxy requests
    #   --apache-proxy-configuration - Extra configuration for the proxy
    #   --apache-proxy-http-configuration - Extra configuration for the proxy HTTP vhost
    #   --apache-proxy-https-configuration - Extra configuration for the proxy HTTPS vhost
    #   --apache-move-htaccess - Move .htaccess files to a common place so they can be loaded during Apache startup (only allowed when type is not defined)
    # NGINX-specific flags:
    #   --nginx-additional-configuration - Additional server block configuration (no default)
    #   --nginx-external-configuration - Configuration external to server block (no default)
    # Returns:
    #   true if the configuration was enabled, false otherwise
    ########################
    ensure_web_server_app_configuration_exists() {
        local app="${1:?missing app}"
        shift
        local -a apache_args nginx_args web_servers args_var
        apache_args=("$app")
        nginx_args=("$app")
        # Validate arguments
        while [[ "$#" -gt 0 ]]; do
            case "$1" in
                # Common flags
                --disable \
                | --disable-http \
                | --disable-https \
                )
                    apache_args+=("$1")
                    nginx_args+=("$1")
                    ;;
                --hosts \
                | --server-name \
                | --server-aliases \
                | --type \
                | --allow-remote-connections \
                | --http-port \
                | --https-port \
                | --document-root \
                )
                    apache_args+=("$1" "${2:?missing value}")
                    nginx_args+=("$1" "${2:?missing value}")
                    shift
                    ;;

                # Specific Apache flags
                --apache-additional-configuration \
                | --apache-additional-http-configuration \
                | --apache-additional-https-configuration \
                | --apache-before-vhost-configuration \
                | --apache-allow-override \
                | --apache-extra-directory-configuration \
                | --apache-proxy-address \
                | --apache-proxy-configuration \
                | --apache-proxy-http-configuration \
                | --apache-proxy-https-configuration \
                | --apache-move-htaccess \
                )
                    apache_args+=("${1//apache-/}" "${2:?missing value}")
                    shift
                    ;;

                # Specific NGINX flags
                --nginx-additional-configuration \
                | --nginx-external-configuration)
                    nginx_args+=("${1//nginx-/}" "${2:?missing value}")
                    shift
                    ;;

                *)
                    echo "Invalid command line flag $1" >&2
                    return 1
                    ;;
            esac
            shift
        done
        read -r -a web_servers <<< "$(web_server_list)"
        for web_server in "${web_servers[@]}"; do
            args_var="${web_server}_args[@]"
            web_server_execute "$web_server" "ensure_${web_server}_app_configuration_exists" "${!args_var}"
        done
    }

    ########################
    # Ensure a web server application configuration does not exist anymore (i.e. Apache virtual host format or NGINX server block)
    # It serves as a wrapper for the specific web server function
    # Globals:
    #   *
    # Arguments:
    #   $1 - App name
    # Returns:
    #   true if the configuration was disabled, false otherwise
    ########################
    ensure_web_server_app_configuration_not_exists() {
        local app="${1:?missing app}"
        local -a web_servers
        read -r -a web_servers <<< "$(web_server_list)"
        for web_server in "${web_servers[@]}"; do
            web_server_execute "$web_server" "ensure_${web_server}_app_configuration_not_exists" "$app"
        done
    }

    ########################
    # Ensure the web server loads the configuration for an application in a URL prefix
    # It serves as a wrapper for the specific web server function
    # Globals:
    #   *
    # Arguments:
    #   $1 - App name
    # Flags:
    #   --allow-remote-connections - Whether to allow remote connections or to require local connections
    #   --document-root - Path to document root directory
    #   --prefix - URL prefix from where it will be accessible (i.e. /myapp)
    #   --type - Application type, which has an effect on what configuration template will be used
    # Apache-specific flags:
    #   --apache-additional-configuration - Additional vhost configuration (no default)
    #   --apache-allow-override - Whether to allow .htaccess files (only allowed when --move-htaccess is set to 'no')
    #   --apache-extra-directory-configuration - Extra configuration for the document root directory
    #   --apache-move-htaccess - Move .htaccess files to a common place so they can be loaded during Apache startup
    # NGINX-specific flags:
    #   --nginx-additional-configuration - Additional server block configuration (no default)
    # Returns:
    #   true if the configuration was enabled, false otherwise
    ########################
    ensure_web_server_prefix_configuration_exists() {
        local app="${1:?missing app}"
        shift
        local -a apache_args nginx_args web_servers args_var
        apache_args=("$app")
        nginx_args=("$app")
        # Validate arguments
        while [[ "$#" -gt 0 ]]; do
            case "$1" in
                # Common flags
                --allow-remote-connections \
                | --document-root \
                | --prefix \
                | --type \
                )
                    apache_args+=("$1" "${2:?missing value}")
                    nginx_args+=("$1" "${2:?missing value}")
                    shift
                    ;;

                # Specific Apache flags
                --apache-additional-configuration \
                | --apache-allow-override \
                | --apache-extra-directory-configuration \
                | --apache-move-htaccess \
                )
                    apache_args+=("${1//apache-/}" "$2")
                    shift
                    ;;

                # Specific NGINX flags
                --nginx-additional-configuration)
                    nginx_args+=("${1//nginx-/}" "$2")
                    shift
                    ;;

                *)
                    echo "Invalid command line flag $1" >&2
                    return 1
                    ;;
            esac
            shift
        done
        read -r -a web_servers <<< "$(web_server_list)"
        for web_server in "${web_servers[@]}"; do
            args_var="${web_server}_args[@]"
            web_server_execute "$web_server" "ensure_${web_server}_prefix_configuration_exists" "${!args_var}"
        done
    }

    ########################
    # Ensure a web server application configuration is updated with the runtime configuration (i.e. ports)
    # It serves as a wrapper for the specific web server function
    # Globals:
    #   *
    # Arguments:
    #   $1 - App name
    # Flags:
    #   --hosts - Host listen addresses
    #   --server-name - Server name
    #   --server-aliases - Server aliases
    #   --enable-http - Enable HTTP app configuration (if not enabled already)
    #   --enable-https - Enable HTTPS app configuration (if not enabled already)
    #   --disable-http - Disable HTTP app configuration (if not disabled already)
    #   --disable-https - Disable HTTPS app configuration (if not disabled already)
    #   --http-port - HTTP port number
    #   --https-port - HTTPS port number
    # Returns:
    #   true if the configuration was updated, false otherwise
    ########################
    web_server_update_app_configuration() {
        local app="${1:?missing app}"
        shift
        local -a args web_servers
        args=("$app")
        # Validate arguments
        while [[ "$#" -gt 0 ]]; do
            case "$1" in
                # Common flags
                --enable-http \
                | --enable-https \
                | --disable-http \
                | --disable-https \
                )
                    args+=("$1")
                    ;;
                --hosts \
                | --server-name \
                | --server-aliases \
                | --http-port \
                | --https-port \
                )
                    args+=("$1" "${2:?missing value}")
                    shift
                    ;;

                *)
                    echo "Invalid command line flag $1" >&2
                    return 1
                    ;;
            esac
            shift
        done
        read -r -a web_servers <<< "$(web_server_list)"
        for web_server in "${web_servers[@]}"; do
            web_server_execute "$web_server" "${web_server}_update_app_configuration" "${args[@]}"
        done
    }

    ########################
    # Enable loading page, which shows users that the initialization process is not yet completed
    # Globals:
    #   *
    # Arguments:
    #   None
    # Returns:
    #   None
    #########################
    web_server_enable_loading_page() {
        ensure_web_server_app_configuration_exists "__loading" --hosts "_default_" \
            --apache-additional-configuration "
    # Show a HTTP 503 Service Unavailable page by default
    RedirectMatch 503 ^/$
    # Show index.html if server is answering with 404 Not Found or 503 Service Unavailable status codes
    ErrorDocument 404 /index.html
    ErrorDocument 503 /index.html" \
            --nginx-additional-configuration "
    # Show a HTTP 503 Service Unavailable page by default
    location / {
      return 503;
    }
    # Show index.html if server is answering with 404 Not Found or 503 Service Unavailable status codes
    error_page 404 @installing;
    error_page 503 @installing;
    location @installing {
      rewrite ^(.*)$ /index.html break;
    }"
        web_server_reload
    }

    ########################
    # Enable loading page, which shows users that the initialization process is not yet completed
    # Globals:
    #   *
    # Arguments:
    #   None
    # Returns:
    #   None
    #########################
    web_server_disable_install_page() {
        ensure_web_server_app_configuration_not_exists "__loading"
        web_server_reload
    }
  redis-sentinel-env.sh: |
    #!/bin/bash
    # Copyright Broadcom, Inc. All Rights Reserved.
    # SPDX-License-Identifier: APACHE-2.0
    #
    # Environment configuration for redis-sentinel

    # The values for all environment variables will be set in the below order of precedence
    # 1. Custom environment variables defined below after Bitnami defaults
    # 2. Constants defined in this file (environment variables with no default), i.e. BITNAMI_ROOT_DIR
    # 3. Environment variables overridden via external files using *_FILE variables (see below)
    # 4. Environment variables set externally (i.e. current Bash context/Dockerfile/userdata)

    # Load logging library
    # shellcheck disable=SC1090,SC1091
    . /etc/redis_scripts/liblog.sh

    export BITNAMI_ROOT_DIR="/opt/bitnami"
    export BITNAMI_VOLUME_DIR="/bitnami"

    # Logging configuration
    export MODULE="${MODULE:-redis-sentinel}"
    export BITNAMI_DEBUG="${BITNAMI_DEBUG:-false}"

    # By setting an environment variable matching *_FILE to a file path, the prefixed environment
    # variable will be overridden with the value specified in that file
    redis_sentinel_env_vars=(
        REDIS_SENTINEL_DATA_DIR
        REDIS_SENTINEL_DISABLE_COMMANDS
        REDIS_SENTINEL_DATABASE
        REDIS_SENTINEL_AOF_ENABLED
        REDIS_SENTINEL_HOST
        REDIS_SENTINEL_MASTER_NAME
        REDIS_SENTINEL_PORT_NUMBER
        REDIS_SENTINEL_QUORUM
        REDIS_SENTINEL_DOWN_AFTER_MILLISECONDS
        REDIS_SENTINEL_FAILOVER_TIMEOUT
        REDIS_SENTINEL_MASTER_REBOOT_DOWN_AFTER_PERIOD
        REDIS_SENTINEL_RESOLVE_HOSTNAMES
        REDIS_SENTINEL_ANNOUNCE_HOSTNAMES
        ALLOW_EMPTY_PASSWORD
        REDIS_SENTINEL_PASSWORD
        REDIS_MASTER_USER
        REDIS_MASTER_PASSWORD
        REDIS_SENTINEL_ANNOUNCE_IP
        REDIS_SENTINEL_ANNOUNCE_PORT
        REDIS_SENTINEL_TLS_ENABLED
        REDIS_SENTINEL_TLS_PORT_NUMBER
        REDIS_SENTINEL_TLS_CERT_FILE
        REDIS_SENTINEL_TLS_KEY_FILE
        REDIS_SENTINEL_TLS_CA_FILE
        REDIS_SENTINEL_TLS_DH_PARAMS_FILE
        REDIS_SENTINEL_TLS_AUTH_CLIENTS
        REDIS_MASTER_HOST
        REDIS_MASTER_PORT_NUMBER
        REDIS_MASTER_SET
    )
    for env_var in "${redis_sentinel_env_vars[@]}"; do
        file_env_var="${env_var}_FILE"
        if [[ -n "${!file_env_var:-}" ]]; then
            if [[ -r "${!file_env_var:-}" ]]; then
                export "${env_var}=$(< "${!file_env_var}")"
                unset "${file_env_var}"
            else
                warn "Skipping export of '${env_var}'. '${!file_env_var:-}' is not readable."
            fi
        fi
    done
    unset redis_sentinel_env_vars

    # Paths
    export REDIS_SENTINEL_VOLUME_DIR="/bitnami/redis-sentinel"
    export REDIS_SENTINEL_BASE_DIR="${BITNAMI_ROOT_DIR}/redis-sentinel"
    export REDIS_SENTINEL_CONF_DIR="${REDIS_SENTINEL_BASE_DIR}/etc"
    export REDIS_SENTINEL_DEFAULT_CONF_DIR="${REDIS_SENTINEL_BASE_DIR}/etc.default"
    export REDIS_SENTINEL_DATA_DIR="${REDIS_SENTINEL_DATA_DIR:-${REDIS_SENTINEL_VOLUME_DIR}/data}"
    export REDIS_SENTINEL_MOUNTED_CONF_DIR="${REDIS_SENTINEL_BASE_DIR}/mounted-etc"
    export REDIS_SENTINEL_CONF_FILE="${REDIS_SENTINEL_CONF_DIR}/sentinel.conf"
    export REDIS_SENTINEL_LOG_DIR="${REDIS_SENTINEL_BASE_DIR}/logs"
    export REDIS_SENTINEL_TMP_DIR="${REDIS_SENTINEL_BASE_DIR}/tmp"
    export REDIS_SENTINEL_PID_FILE="${REDIS_SENTINEL_TMP_DIR}/redis-sentinel.pid"
    export REDIS_SENTINEL_BIN_DIR="${REDIS_SENTINEL_BASE_DIR}/bin"
    export PATH="${REDIS_SENTINEL_BIN_DIR}:${BITNAMI_ROOT_DIR}/common/bin:${PATH}"

    # System users (when running with a privileged user)
    export REDIS_SENTINEL_DAEMON_USER="redis"
    export REDIS_SENTINEL_DAEMON_GROUP="redis"

    # Redis Sentinel settings
    export REDIS_SENTINEL_DISABLE_COMMANDS="${REDIS_SENTINEL_DISABLE_COMMANDS:-}"
    export REDIS_SENTINEL_DATABASE="${REDIS_SENTINEL_DATABASE:-redis}"
    export REDIS_SENTINEL_AOF_ENABLED="${REDIS_SENTINEL_AOF_ENABLED:-yes}"
    export REDIS_SENTINEL_HOST="${REDIS_SENTINEL_HOST:-}"
    export REDIS_SENTINEL_MASTER_NAME="${REDIS_SENTINEL_MASTER_NAME:-}"
    export REDIS_SENTINEL_DEFAULT_PORT_NUMBER="26379" # only used at build time
    export REDIS_SENTINEL_PORT_NUMBER="${REDIS_SENTINEL_PORT_NUMBER:-$REDIS_SENTINEL_DEFAULT_PORT_NUMBER}"
    export REDIS_SENTINEL_QUORUM="${REDIS_SENTINEL_QUORUM:-2}"
    export REDIS_SENTINEL_DOWN_AFTER_MILLISECONDS="${REDIS_SENTINEL_DOWN_AFTER_MILLISECONDS:-60000}"
    export REDIS_SENTINEL_FAILOVER_TIMEOUT="${REDIS_SENTINEL_FAILOVER_TIMEOUT:-180000}"
    export REDIS_SENTINEL_MASTER_REBOOT_DOWN_AFTER_PERIOD="${REDIS_SENTINEL_MASTER_REBOOT_DOWN_AFTER_PERIOD:-0}"
    export REDIS_SENTINEL_RESOLVE_HOSTNAMES="${REDIS_SENTINEL_RESOLVE_HOSTNAMES:-yes}"
    export REDIS_SENTINEL_ANNOUNCE_HOSTNAMES="${REDIS_SENTINEL_ANNOUNCE_HOSTNAMES:-no}"
    export ALLOW_EMPTY_PASSWORD="${ALLOW_EMPTY_PASSWORD:-no}"
    export REDIS_SENTINEL_PASSWORD="${REDIS_SENTINEL_PASSWORD:-}"
    export REDIS_MASTER_USER="${REDIS_MASTER_USER:-}"
    export REDIS_MASTER_PASSWORD="${REDIS_MASTER_PASSWORD:-}"
    export REDIS_SENTINEL_ANNOUNCE_IP="${REDIS_SENTINEL_ANNOUNCE_IP:-}"
    export REDIS_SENTINEL_ANNOUNCE_PORT="${REDIS_SENTINEL_ANNOUNCE_PORT:-}"

    # TLS settings
    export REDIS_SENTINEL_TLS_ENABLED="${REDIS_SENTINEL_TLS_ENABLED:-no}"
    export REDIS_SENTINEL_TLS_PORT_NUMBER="${REDIS_SENTINEL_TLS_PORT_NUMBER:-26379}"
    export REDIS_SENTINEL_TLS_CERT_FILE="${REDIS_SENTINEL_TLS_CERT_FILE:-}"
    export REDIS_SENTINEL_TLS_KEY_FILE="${REDIS_SENTINEL_TLS_KEY_FILE:-}"
    export REDIS_SENTINEL_TLS_CA_FILE="${REDIS_SENTINEL_TLS_CA_FILE:-}"
    export REDIS_SENTINEL_TLS_DH_PARAMS_FILE="${REDIS_SENTINEL_TLS_DH_PARAMS_FILE:-}"
    export REDIS_SENTINEL_TLS_AUTH_CLIENTS="${REDIS_SENTINEL_TLS_AUTH_CLIENTS:-yes}"

    # Redis Master settings
    export REDIS_MASTER_HOST="${REDIS_MASTER_HOST:-redis}"
    export REDIS_MASTER_PORT_NUMBER="${REDIS_MASTER_PORT_NUMBER:-6379}"
    export REDIS_MASTER_SET="${REDIS_MASTER_SET:-mymaster}"

    # Custom environment variables may be defined below
{{ end }}
